{"version":3,"file":"extractManifestAction.js","sources":["../../src/_internal/cli/actions/manifest/extractManifestAction.ts"],"sourcesContent":["import {createHash} from 'node:crypto'\nimport {mkdir, writeFile} from 'node:fs/promises'\nimport {dirname, join, resolve} from 'node:path'\nimport {Worker} from 'node:worker_threads'\n\nimport {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'\nimport {minutesToMilliseconds} from 'date-fns'\nimport readPkgUp from 'read-pkg-up'\n\nimport {\n  type CreateManifest,\n  type CreateWorkspaceManifest,\n  type ManifestWorkspaceFile,\n} from '../../../manifest/manifestTypes'\nimport {type ExtractManifestWorkerData} from '../../threads/extractManifest'\nimport {readModuleVersion} from '../../util/readModuleVersion'\nimport {getTimer} from '../../util/timing'\n\nexport const MANIFEST_FILENAME = 'create-manifest.json'\nconst SCHEMA_FILENAME_SUFFIX = '.create-schema.json'\nconst TOOLS_FILENAME_SUFFIX = '.create-tools.json'\n\n/** Escape-hatch env flags to change action behavior */\nconst FEATURE_ENABLED_ENV_NAME = 'SANITY_CLI_EXTRACT_MANIFEST_ENABLED'\nconst EXTRACT_MANIFEST_ENABLED = process.env[FEATURE_ENABLED_ENV_NAME] !== 'false'\nconst EXTRACT_MANIFEST_LOG_ERRORS = process.env.SANITY_CLI_EXTRACT_MANIFEST_LOG_ERRORS === 'true'\n\nconst CREATE_TIMER = 'create-manifest'\n\nconst EXTRACT_TASK_TIMEOUT_MS = minutesToMilliseconds(2)\n\nconst EXTRACT_FAILURE_MESSAGE =\n  \"â†³ Couldn't extract manifest file. Sanity Create will not be available for the studio.\\n\" +\n  `  Disable this message with ${FEATURE_ENABLED_ENV_NAME}=false`\n\nexport interface ExtractManifestFlags {\n  path?: string\n}\n\n/**\n * This function will never throw.\n * @returns `undefined` if extract succeeded - caught error if it failed\n */\nexport async function extractManifestSafe(\n  args: CliCommandArguments<ExtractManifestFlags>,\n  context: CliCommandContext,\n): Promise<Error | undefined> {\n  if (!EXTRACT_MANIFEST_ENABLED) {\n    return undefined\n  }\n\n  try {\n    await extractManifest(args, context)\n    return undefined\n  } catch (err) {\n    if (EXTRACT_MANIFEST_LOG_ERRORS) {\n      context.output.error(err)\n    }\n    return err\n  }\n}\n\nasync function extractManifest(\n  args: CliCommandArguments<ExtractManifestFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const {output, workDir} = context\n\n  const flags = args.extOptions\n  const defaultOutputDir = resolve(join(workDir, 'dist'))\n\n  const outputDir = resolve(defaultOutputDir)\n  const defaultStaticPath = join(outputDir, 'static')\n\n  const staticPath = flags.path ?? defaultStaticPath\n\n  const path = join(staticPath, MANIFEST_FILENAME)\n\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const timer = getTimer()\n  timer.start(CREATE_TIMER)\n  const spinner = output.spinner({}).start('Extracting manifest')\n\n  try {\n    const workspaceManifests = await getWorkspaceManifests({rootPkgPath, workDir})\n    await mkdir(staticPath, {recursive: true})\n\n    const workspaceFiles = await writeWorkspaceFiles(workspaceManifests, staticPath)\n\n    const manifest: CreateManifest = {\n      /**\n       * Version history:\n       * 1: Initial release.\n       * 2: Added tools file.\n       * 3. Added studioVersion field.\n       */\n      version: 3,\n      createdAt: new Date().toISOString(),\n      workspaces: workspaceFiles,\n      studioVersion: await readModuleVersion(workDir, 'sanity'),\n    }\n\n    await writeFile(path, JSON.stringify(manifest, null, 2))\n    const manifestDuration = timer.end(CREATE_TIMER)\n\n    spinner.succeed(`Extracted manifest (${manifestDuration.toFixed()}ms)`)\n  } catch (err) {\n    spinner.fail(err.message)\n    throw err\n  }\n}\n\nasync function getWorkspaceManifests({\n  rootPkgPath,\n  workDir,\n}: {\n  rootPkgPath: string\n  workDir: string\n}): Promise<CreateWorkspaceManifest[]> {\n  const workerPath = join(\n    dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'extractManifest.js',\n  )\n\n  const worker = new Worker(workerPath, {\n    workerData: {workDir} satisfies ExtractManifestWorkerData,\n    env: process.env,\n  })\n\n  let timeout = false\n  const timeoutId = setTimeout(() => {\n    timeout = true\n    void worker.terminate()\n  }, EXTRACT_TASK_TIMEOUT_MS)\n\n  try {\n    return await new Promise<CreateWorkspaceManifest[]>((resolveWorkspaces, reject) => {\n      const buffer: CreateWorkspaceManifest[] = []\n      worker.addListener('message', (message) => buffer.push(message))\n      worker.addListener('exit', (exitCode) => {\n        if (exitCode === 0) {\n          resolveWorkspaces(buffer)\n        } else if (timeout) {\n          reject(new Error(`Extract manifest was aborted after ${EXTRACT_TASK_TIMEOUT_MS}ms`))\n        }\n      })\n      worker.addListener('error', reject)\n    })\n  } finally {\n    clearTimeout(timeoutId)\n  }\n}\n\nfunction writeWorkspaceFiles(\n  manifestWorkspaces: CreateWorkspaceManifest[],\n  staticPath: string,\n): Promise<ManifestWorkspaceFile[]> {\n  const output = manifestWorkspaces.reduce<Promise<ManifestWorkspaceFile>[]>(\n    (workspaces, workspace) => {\n      return [...workspaces, writeWorkspaceFile(workspace, staticPath)]\n    },\n    [],\n  )\n  return Promise.all(output)\n}\n\nasync function writeWorkspaceFile(\n  workspace: CreateWorkspaceManifest,\n  staticPath: string,\n): Promise<ManifestWorkspaceFile> {\n  const [schemaFilename, toolsFilename] = await Promise.all([\n    createFile(staticPath, workspace.schema, SCHEMA_FILENAME_SUFFIX),\n    createFile(staticPath, workspace.tools, TOOLS_FILENAME_SUFFIX),\n  ])\n\n  return {\n    ...workspace,\n    schema: schemaFilename,\n    tools: toolsFilename,\n  }\n}\n\nconst createFile = async (path: string, content: any, filenameSuffix: string) => {\n  const stringifiedContent = JSON.stringify(content, null, 2)\n  const hash = createHash('sha1').update(stringifiedContent).digest('hex')\n  const filename = `${hash.slice(0, 8)}${filenameSuffix}`\n\n  // workspaces with identical data will overwrite each others file. This is ok, since they are identical and can be shared\n  await writeFile(join(path, filename), stringifiedContent)\n\n  return filename\n}\n"],"names":["MANIFEST_FILENAME","SCHEMA_FILENAME_SUFFIX","TOOLS_FILENAME_SUFFIX","FEATURE_ENABLED_ENV_NAME","EXTRACT_MANIFEST_ENABLED","process","env","EXTRACT_MANIFEST_LOG_ERRORS","SANITY_CLI_EXTRACT_MANIFEST_LOG_ERRORS","CREATE_TIMER","EXTRACT_TASK_TIMEOUT_MS","minutesToMilliseconds","extractManifestSafe","args","context","extractManifest","err","output","error","workDir","flags","extOptions","defaultOutputDir","resolve","join","outputDir","defaultStaticPath","staticPath","path","rootPkgPath","readPkgUp","sync","cwd","__dirname","Error","timer","getTimer","start","spinner","workspaceManifests","getWorkspaceManifests","mkdir","recursive","workspaceFiles","writeWorkspaceFiles","manifest","version","createdAt","Date","toISOString","workspaces","studioVersion","readModuleVersion","writeFile","JSON","stringify","manifestDuration","end","succeed","toFixed","fail","message","workerPath","dirname","worker","Worker","workerData","timeout","timeoutId","setTimeout","terminate","Promise","resolveWorkspaces","reject","buffer","addListener","push","exitCode","clearTimeout","manifestWorkspaces","reduce","workspace","writeWorkspaceFile","all","schemaFilename","toolsFilename","createFile","schema","tools","content","filenameSuffix","stringifiedContent","filename","createHash","update","digest","slice"],"mappings":"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"}