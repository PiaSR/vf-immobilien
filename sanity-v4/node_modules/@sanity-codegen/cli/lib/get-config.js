"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConfig = getConfig;
var _path = _interopRequireDefault(require("path"));
var _fs = _interopRequireDefault(require("fs"));
var _babelMerge = _interopRequireDefault(require("babel-merge"));
var _register = _interopRequireWildcard(require("@babel/register"));
var _errors = require("@oclif/errors");
var _extractor = require("@sanity-codegen/extractor");
var _fileWalker = require("./file-walker");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error no types for this

// @ts-expect-error no types for this

const requireDefaultExport = modulePath => {
  const module = require(modulePath);
  return module.default || module;
};
async function getConfig({
  flags,
  logger
}) {
  try {
    const configFilename = await (0, _fileWalker.fileWalker)({
      startingPoint: flags.configPath || process.cwd(),
      filenameIfNotFound: 'sanity-codegen.config'
    });
    const configDirname = configFilename && _path.default.dirname(configFilename);
    if (configFilename) {
      logger.info(`Using sanity-codegen config found at: ${_path.default.relative(process.cwd(), configFilename)}`);
    }
    (0, _register.default)(_extractor.defaultBabelOptions);
    const configFirstPass = configFilename && requireDefaultExport(configFilename);
    const root = configDirname && configFirstPass ? _path.default.resolve(configDirname, configFirstPass.root || '') : process.cwd();
    const babelOptionsLiteralFromFlags = flags.babelOptions ? (() => {
      try {
        return JSON.parse(flags.babelOptions);
      } catch {
        throw new _errors.CLIError('Failed to parse provided `babelOptions`. Please provide an escaped JSON string.');
      }
    })() : null;
    const babelOptionsLiteralFromConfig = configFirstPass?.babelOptions || null;
    const unresolvedBabelrcPath = flags.babelrcPath || configFirstPass?.babelrcPath;
    const babelrcPath = unresolvedBabelrcPath ? _path.default.resolve(root, unresolvedBabelrcPath) : null;
    if (babelrcPath && !_fs.default.existsSync(babelrcPath)) {
      throw new _errors.CLIError(`Could not find babelrc from provided babelrcPath: ${babelrcPath}`);
    }

    // TODO(docs): if no babelrc is found then we don't go looking for one
    const babelOptionsFromBabelrc = (() => {
      if (!babelrcPath) return null;
      const resolvedBabelrcPath = _path.default.resolve(root || '', babelrcPath);
      try {
        return requireDefaultExport(resolvedBabelrcPath);
      } catch {
        throw new _errors.CLIError(`Failed to load babelrc at path: ${resolvedBabelrcPath} ` + `Ensure that this path is valid or remove the \`babelrcPath\` option.`);
      }
    })();
    if (babelOptionsFromBabelrc && babelrcPath) {
      logger.info(`Using babelrc config found at: ${_path.default.relative(root, babelrcPath)}`);
    }
    const babelOptions = (0, _babelMerge.default)(_extractor.defaultBabelOptions, (0, _babelMerge.default)(babelOptionsLiteralFromFlags || babelOptionsLiteralFromConfig || {}, babelOptionsFromBabelrc || {}));
    (0, _register.revert)();
    (0, _register.default)(babelOptions);
    const config = configFilename ? requireDefaultExport(configFilename) : null;
    return {
      config,
      babelrcPath,
      babelOptions,
      root
    };
  } finally {
    (0, _register.revert)();
  }
}