"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _command = require("@oclif/command");
var _commonTags = require("common-tags");
var _path = _interopRequireDefault(require("path"));
var _fs = _interopRequireDefault(require("fs"));
var _core = require("@sanity-codegen/core");
var _extractor = require("@sanity-codegen/extractor");
var _getConfig = require("../get-config");
var _createAnimatedLogger = require("../create-animated-logger");
var _simpleLogger = require("../simple-logger");
var _getSanityConfigPath = require("../get-sanity-config-path");
var _registerDotEnv = require("../register-dot-env");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GroqCodegen extends _command.Command {
  logger = process.env.CI === 'true' || process.env.NODE_ENV === 'test' ? _simpleLogger.simpleLogger : (0, _createAnimatedLogger.createAnimatedLogger)();
  static description = (0, _commonTags.stripIndents)`
    parses source code files for GROQ queries and outputs TypeScript types from them
  `;
  static flags = {
    help: _command.flags.help({
      char: 'h'
    }),
    root: _command.flags.string({
      name: 'root',
      description: (0, _commonTags.stripIndents)`
        Determines from where files are relative to. Defaults to where your
        sanity-codegen config was found (if any) or the current working
        directory.
      `
    }),
    sanityConfigPath: _command.flags.string({
      name: 'sanityConfigPath',
      description: (0, _commonTags.stripIndents)`
        Optionally provide an exact path for the CLI to look for a sanity
        configuration file (sanity.config.[t|j]s). If not provided, the CLI will
        try to default to the current working directory.

        Any CLI flags passed with override the config options.
      `
    }),
    configPath: _command.flags.string({
      name: 'configPath',
      description: (0, _commonTags.stripIndents)`
        Optionally provide an exact path for the CLI to look for a
        sanity-codegen configuration file. If not provided, the CLI will walk up
        the file system checking for \`sanity-codegen.config.js\` or
        \`sanity-codegen.config.ts\`.

        Any CLI flags passed with override the config options.
      `
    }),
    output: _command.flags.string({
      name: 'output',
      description: (0, _commonTags.stripIndents)`
        Optionally provide a destination path to the resulting sanity groq
        types. The default value is \`sanity-codegen.d.ts\`.
      `
    }),
    include: _command.flags.string({
      name: 'include',
      description: (0, _commonTags.stripIndents)`
        Specify a glob or a list of globs to specify which source files you want
        to include from type generation. Powered by globby.
      `
    }),
    exclude: _command.flags.string({
      name: 'exclude',
      description: (0, _commonTags.stripIndents)`
        Specify a glob or a list of globs to specify which source files you want
        to exclude from type generation. Powered by globby.
      `
    }),
    ignoreSchemas: _command.flags.string({
      name: 'ignoreSchemas',
      description: (0, _commonTags.stripIndents)`
        A common separated list that tells the codegen to ignores workspace
        schemas and exclude them from codegen. Useful if you have a workspace
        that mirrors another one in schema (e.g. staging env).
      `
    })
  };
  static args = [{
    name: 'include',
    description: (0, _commonTags.stripIndents)`
        Provide a glob to match source files you wish to parse for GROQ queries.
      `
  }];
  async run() {
    const {
      logger
    } = this;
    logger.verbose('Starting codegen…');
    const {
      args,
      flags
    } = this.parse(GroqCodegen);
    const {
      config,
      root,
      babelOptions
    } = await (0, _getConfig.getConfig)({
      flags,
      logger
    });
    (0, _registerDotEnv.registerDotEnv)(process.env.NODE_ENV === 'production' ? 'production' : 'development', root);
    let normalizedSchemas;
    if (config?.normalizedSchemas) {
      normalizedSchemas = config.normalizedSchemas;
    } else {
      const {
        babelOptions,
        config,
        babelrcPath,
        root
      } = await (0, _getConfig.getConfig)({
        flags,
        logger
      });
      const sanityConfigPath = await (0, _getSanityConfigPath.getSanityConfigPath)({
        config,
        args,
        root,
        logger
      });
      logger.verbose(`Extracting schema from sanity config (this may take some time)…`);
      normalizedSchemas = await (0, _extractor.schemaExtractor)({
        sanityConfigPath,
        babelrcPath: babelrcPath || undefined,
        babelOptions,
        cwd: root
      });
      logger.success(`Extracted schema.`);
    }
    const include = flags.include || config?.include || ['./src/**/*.{js,ts,tsx}'];
    const exclude = flags.exclude || config?.exclude || ['**/node_modules'];
    const ignoreSchemasFromFlags = flags.ignoreSchemas?.split(',').map(i => i.trim()).filter(Boolean);
    const ignoreSchemas = ignoreSchemasFromFlags || config?.ignoreSchemas;
    const result = await (0, _core.generateTypes)({
      include,
      exclude,
      babelOptions,
      prettierResolveConfigOptions: config?.prettierResolveConfigOptions,
      prettierResolveConfigPath: config?.prettierResolveConfigPath,
      root,
      normalizedSchemas,
      logger,
      ignoreSchemas
    });
    const output = _path.default.resolve(root, flags.output || config?.output || 'sanity-codegen.d.ts');
    const outputDir = _path.default.dirname(output);
    if (!_fs.default.existsSync(outputDir)) {
      await _fs.default.promises.mkdir(outputDir, {
        recursive: true
      });
    }
    logger.verbose('Writing query types output…');
    await _fs.default.promises.writeFile(output, result);
    logger.success(`Wrote types to: ${_path.default.relative(root, output)}`);
  }
}
exports.default = GroqCodegen;