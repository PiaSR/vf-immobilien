"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateTypes = generateTypes;
var _generator = _interopRequireDefault(require("@babel/generator"));
var _prettier = require("prettier");
var _pluckGroqFromFiles = require("./pluck-groq-from-files");
var _utils = require("./utils");
var _generateQueryTypes = require("./generate-query-types");
var _generateSchemaTypes = require("./generate-schema-types");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const logLevels = ['success', 'error', 'warn', 'info', 'verbose', 'debug'];
/**
 * Given a selection of filenames, this will pluck matching GROQ queries
 * (@see `pluckGroqFromFiles`) and then run them through a GROQ-to-TypeScript
 * transform.
 *
 * The result of each plucked query is put together into one source string.
 */
async function generateTypes({
  prettierResolveConfigOptions,
  prettierResolveConfigPath,
  normalizedSchemas,
  ignoreSchemas = [],
  ...pluckOptions
}) {
  const {
    logger = _utils.simpleLogger
  } = pluckOptions;
  const declarations = {};
  const substitutions = {};
  const filteredSchemas = normalizedSchemas.filter(schema => !ignoreSchemas.includes(schema.name));
  for (let i = 0; i < filteredSchemas.length; i++) {
    const normalizedSchema = filteredSchemas[i];
    const wrappedLogger = logLevels.reduce((acc, next) => {
      const prefix = `[${normalizedSchema.name}]${normalizedSchemas.length > 1 ? ` (${i + 1}/${normalizedSchemas.length})` : ''}`;
      acc[next] = message => logger[next](`${prefix} ${message}`);
      return acc;
    }, {
      ...logger
    });
    wrappedLogger.verbose(`Generating types for workspace \`${normalizedSchema.name}\``);
    const schemaTypes = (0, _generateSchemaTypes.generateSchemaTypes)({
      normalizedSchema
    });
    const schemaCount = Object.keys(schemaTypes.declarations).length;
    wrappedLogger[schemaCount ? 'success' : 'warn'](`Converted ${schemaCount} schema definition${schemaCount === 1 ? '' : 's'} to TypeScript`);
    for (const [key, value] of Object.entries(schemaTypes.declarations)) {
      declarations[key] = value;
    }
    for (const [key, value] of Object.entries(schemaTypes.substitutions)) {
      substitutions[key] = value;
    }
    wrappedLogger.verbose(`Plucking queries from files…`);
    const extractedQueries = await (0, _pluckGroqFromFiles.pluckGroqFromFiles)({
      ...pluckOptions,
      logger: wrappedLogger
    });
    wrappedLogger.verbose(`Converting queries to typescript…`);
    const queryTypes = (0, _generateQueryTypes.generateQueryTypes)({
      normalizedSchema,
      substitutions: schemaTypes.substitutions,
      extractedQueries
    });
    const queryCount = Object.keys(queryTypes.declarations).length;
    wrappedLogger[queryCount ? 'success' : 'success'](`Converted ${queryCount} ${queryCount === 1 ? 'query' : 'queries'} to TypeScript`);
    for (const [key, value] of Object.entries(queryTypes.declarations)) {
      declarations[key] = value;
    }
    for (const [key, value] of Object.entries(queryTypes.substitutions)) {
      substitutions[key] = value;
    }
  }
  const finalCodegen = `
    /// <reference types="@sanity-codegen/types" />

    ${Object.values(declarations).map(declaration => (0, _generator.default)(declaration).code).sort((a, b) => a.localeCompare(b, 'en')).join('\n')}
  `;
  const resolvedConfig = prettierResolveConfigPath ? await (0, _prettier.resolveConfig)(prettierResolveConfigPath, prettierResolveConfigOptions) : null;
  return (0, _prettier.format)(finalCodegen, {
    ...resolvedConfig,
    parser: 'typescript'
  });
}