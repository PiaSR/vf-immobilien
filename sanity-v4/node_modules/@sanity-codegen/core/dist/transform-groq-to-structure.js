"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformGroqToStructure = transformGroqToStructure;
var _utils = require("./utils");
var _transformSchemaToStructure = require("./transform-schema-to-structure");
/**
 * Used to transform a GROQ AST (e.g. `ExprNode`) into a `StructureNode`
 */
function transformGroqToStructure({
  node,
  normalizedSchema,
  scopes
}) {
  const scope = scopes[scopes.length - 1];
  switch (node.type) {
    case 'Everything':
      {
        return (0, _transformSchemaToStructure.transformSchemaToStructure)({
          normalizedSchema: normalizedSchema
        });
      }

    // TODO: are these actually the same?
    case 'Map':
    case 'FlatMap':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        const exprResult = transformGroqToStructure({
          node: node.expr,
          scopes: [...scopes, baseResult],
          normalizedSchema
        });
        return exprResult;
      }
    case 'Filter':
      {
        // e.g. the return type from everything
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (!(0, _utils.isStructureArray)(baseResult)) {
          // TODO: warn that filter was used on non-array base
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _utils.wrapArray)((0, _utils.narrowStructure)((0, _utils.unwrapArray)(baseResult), node.expr), {
          canBeOptional: false,
          canBeNull: (0, _utils.isStructureNull)(baseResult)
        });
      }
    case 'This':
      {
        // TODO: could warn here
        return scope || (0, _utils.createStructure)({
          type: 'Unknown'
        });
      }
    case 'Parent':
      {
        // TODO: support parent `n` operator
        const parentScope = scopes[scopes.length - 2];
        // TODO: could warn here
        return parentScope || (0, _utils.createStructure)({
          type: 'Unknown'
        });
      }
    case 'Parameter':
      {
        // Not very easy to know what the intended type of a parameter is so we
        // convert it to `Unknown`. For some cases (such as filtering), this
        // shouldn't have an impact on the resulting types
        return (0, _utils.createStructure)({
          type: 'Unknown'
        });
      }
    case 'AccessElement':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (baseResult.type === 'Unknown') {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _utils.addNull)((0, _utils.removeOptional)((0, _utils.unwrapArray)(baseResult)));
      }
    case 'Projection':
      {
        // e.g. the result of a filter
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        const baseResultHadArray = (0, _utils.isStructureArray)(baseResult);
        const exprResult = transformGroqToStructure({
          node: node.expr,
          scopes: [...scopes, baseResultHadArray ? (0, _utils.unwrapArray)(baseResult) : baseResult],
          normalizedSchema
        });
        return baseResultHadArray ? (0, _utils.wrapArray)(exprResult, {
          canBeNull: (0, _utils.isStructureNull)(baseResult),
          canBeOptional: (0, _utils.isStructureOptional)(baseResult)
        }) : exprResult;
      }
    case 'Object':
      {
        if (!node.attributes.length) {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        const emptyObject = (0, _utils.createStructure)({
          type: 'Object',
          canBeNull: false,
          canBeOptional: false,
          properties: []
        });
        const combinedObject = node.attributes.reduce((acc, attribute) => {
          switch (attribute.type) {
            case 'ObjectAttributeValue':
              {
                const value = transformGroqToStructure({
                  node: attribute.value,
                  normalizedSchema,
                  scopes
                });
                const singlePropertyObject = (0, _utils.createStructure)({
                  type: 'Object',
                  canBeNull: false,
                  canBeOptional: false,
                  properties: [{
                    key: attribute.name,
                    value: (0, _utils.isStructureOptional)(value) ? (0, _utils.addNull)((0, _utils.removeOptional)(value)) : value
                  }]
                });
                return (0, _utils.reduceObjectStructures)(acc, singlePropertyObject, 'replace');
              }
            case 'ObjectSplat':
              {
                const value = transformGroqToStructure({
                  node: attribute.value,
                  normalizedSchema,
                  scopes
                });
                return (0, _utils.reduceObjectStructures)(acc, value, 'replace');
              }
            case 'ObjectConditionalSplat':
              {
                const value = transformGroqToStructure({
                  node: attribute.value,
                  scopes,
                  normalizedSchema
                });
                return (0, _utils.reduceObjectStructures)(acc, (0, _utils.addOptionalToProperties)(value), 'union');
              }
            default:
              {
                console.warn(
                // @ts-expect-error `attribute` should be of type never
                `Found unsupported object attribute type "${attribute.type}"`);
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
          }
        }, emptyObject);
        return combinedObject;
      }
    case 'Select':
      {
        const children = node.alternatives.map(alternative => transformGroqToStructure({
          node: alternative.value,
          scopes,
          normalizedSchema
        }));
        if (node.fallback) {
          children.push(transformGroqToStructure({
            node: node.fallback,
            scopes,
            normalizedSchema
          }));
        }
        return (0, _utils.createStructure)({
          type: 'Or',
          children
        });
      }
    case 'Array':
      {
        // if there is a splat in the array literal then…
        if (node.elements.some(element => element.isSplat)) {
          return (0, _utils.createStructure)({
            // …we can't map to tuple type
            type: 'Array',
            canBeNull: false,
            canBeOptional: false,
            of: (0, _utils.createStructure)({
              type: 'Or',
              children: node.elements.map(element => {
                if (element.isSplat) {
                  return (0, _utils.unwrapArray)(transformGroqToStructure({
                    node: element.value,
                    scopes,
                    normalizedSchema
                  }));
                }
                return transformGroqToStructure({
                  node: element.value,
                  scopes,
                  normalizedSchema
                });
              })
            })
          });
        }

        // if there are no splats found, we can list each type out as a tuple
        // to allow for better DX with decomposition
        return (0, _utils.createStructure)({
          type: 'Tuple',
          canBeNull: false,
          canBeOptional: false,
          elements: node.elements.map(element => transformGroqToStructure({
            node: element.value,
            scopes,
            normalizedSchema
          }))
        });
      }
    case 'AccessAttribute':
      {
        if (node.base) {
          const baseResult = transformGroqToStructure({
            node: node.base,
            scopes: scopes,
            normalizedSchema
          });
          const next = {
            ...node
          };
          delete next.base;
          return transformGroqToStructure({
            node: next,
            scopes: [...scopes, baseResult],
            normalizedSchema
          });
        }
        if (!scope) return (0, _utils.createStructure)({
          type: 'Unknown'
        });
        return (0, _utils.accessAttributeInStructure)(scope, node.name);
      }
    case 'Deref':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        return (0, _utils.unwrapReferences)(baseResult);
      }
    case 'Slice':
    case 'Group':
    case 'ArrayCoerce':
    case 'Asc':
    case 'Desc':
      {
        return transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
      }
    case 'Value':
      {
        switch (typeof node.value) {
          case 'string':
            {
              return (0, _utils.createStructure)({
                type: 'String',
                canBeNull: false,
                canBeOptional: false,
                value: node.value
              });
            }
          case 'number':
            {
              return (0, _utils.createStructure)({
                type: 'Number',
                canBeNull: false,
                canBeOptional: false,
                value: node.value
              });
            }
          case 'boolean':
            {
              return (0, _utils.createStructure)({
                type: 'Boolean',
                canBeNull: false,
                canBeOptional: false
              });
            }
          default:
            {
              return (0, _utils.createStructure)({
                type: 'Unknown'
              });
            }
        }
      }
    case 'Or':
    case 'And':
      {
        const leftResult = transformGroqToStructure({
          node: node.left,
          normalizedSchema,
          scopes
        });
        const rightResult = transformGroqToStructure({
          node: node.right,
          normalizedSchema,
          scopes
        });

        // TODO: could warn in these cases
        if (!(0, _utils.isStructureBoolean)(leftResult)) {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        if (!(0, _utils.isStructureBoolean)(rightResult)) {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _utils.createStructure)({
          type: 'Boolean',
          canBeNull: (0, _utils.isStructureNull)(leftResult) || (0, _utils.isStructureNull)(rightResult),
          canBeOptional: (0, _utils.isStructureOptional)(leftResult) || (0, _utils.isStructureOptional)(rightResult)
        });
      }
    case 'Not':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (!(0, _utils.isStructureBoolean)(baseResult)) {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _utils.createStructure)({
          type: 'Boolean',
          canBeNull: (0, _utils.isStructureNull)(baseResult),
          canBeOptional: (0, _utils.isStructureOptional)(baseResult)
        });
      }
    case 'Pos':
    case 'Neg':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (!(0, _utils.isStructureNumber)(baseResult)) {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _utils.createStructure)({
          type: 'Number',
          canBeNull: (0, _utils.isStructureNull)(baseResult),
          canBeOptional: (0, _utils.isStructureOptional)(baseResult),
          value: null
        });
      }
    case 'OpCall':
      {
        const leftStructure = transformGroqToStructure({
          node: node.left,
          scopes,
          normalizedSchema
        });
        const rightStructure = transformGroqToStructure({
          node: node.right,
          scopes,
          normalizedSchema
        });
        const canBeNull = (0, _utils.isStructureNull)(leftStructure) || (0, _utils.isStructureNull)(rightStructure);
        const canBeOptional = (0, _utils.isStructureOptional)(leftStructure) || (0, _utils.isStructureOptional)(rightStructure);
        switch (node.op) {
          case '*':
          case '**':
          case '-':
          case '/':
          case '%':
            {
              if (!(0, _utils.isStructureNumber)(leftStructure) || !(0, _utils.isStructureNumber)(rightStructure)) {
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'Number',
                canBeNull,
                canBeOptional,
                value: null
              });
            }
          case '<=':
          case '<':
          case '>':
          case '>=':
            {
              if (!(0, _utils.isStructureNumber)(leftStructure) || !(0, _utils.isStructureNumber)(rightStructure)) {
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'Boolean',
                canBeNull: (0, _utils.isStructureNull)(leftStructure) || (0, _utils.isStructureNull)(rightStructure),
                canBeOptional: (0, _utils.isStructureOptional)(leftStructure) || (0, _utils.isStructureOptional)(rightStructure)
              });
            }
          case '!=':
          case '==':
          case 'in':
          case 'match':
            {
              return (0, _utils.createStructure)({
                type: 'Boolean',
                canBeNull: (0, _utils.isStructureNull)(leftStructure) || (0, _utils.isStructureNull)(rightStructure),
                canBeOptional: (0, _utils.isStructureOptional)(leftStructure) || (0, _utils.isStructureOptional)(rightStructure)
              });
            }
          case '+':
            {
              if ((0, _utils.isStructureNumber)(leftStructure) && (0, _utils.isStructureNumber)(rightStructure)) {
                return (0, _utils.createStructure)({
                  type: 'Number',
                  canBeNull,
                  canBeOptional,
                  value: null
                });
              }
              if ((0, _utils.isStructureString)(leftStructure) && (0, _utils.isStructureString)(rightStructure)) {
                const leftStringStructure = leftStructure;
                const rightStringStructure = rightStructure;
                return (0, _utils.createStructure)({
                  type: 'String',
                  canBeNull,
                  canBeOptional,
                  value: leftStringStructure.value === null ? null : rightStringStructure.value === null ? null : `${leftStringStructure.value}${rightStringStructure.value}`
                });
              }
              return (0, _utils.createStructure)({
                type: 'Unknown'
              });
            }
          default:
            {
              throw new Error(`Found expected operator "${node.op}". Please open an issue.`);
            }
        }
      }
    case 'InRange':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        const leftResult = transformGroqToStructure({
          node: node.left,
          scopes,
          normalizedSchema
        });
        const rightResult = transformGroqToStructure({
          node: node.right,
          scopes,
          normalizedSchema
        });
        if (!(0, _utils.isStructureNumber)(baseResult)) {
          return (0, _utils.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _utils.createStructure)({
          type: 'Boolean',
          canBeNull: (0, _utils.isStructureNull)(baseResult) || (0, _utils.isStructureNull)(leftResult) || (0, _utils.isStructureNull)(rightResult),
          canBeOptional: (0, _utils.isStructureOptional)(baseResult) || (0, _utils.isStructureOptional)(leftResult) || (0, _utils.isStructureOptional)(rightResult)
        });
      }
    case 'FuncCall':
      {
        switch (node.name) {
          case 'coalesce':
            {
              return (0, _utils.createStructure)({
                type: 'Or',
                children: node.args.map(arg => transformGroqToStructure({
                  node: arg,
                  scopes,
                  normalizedSchema
                }))
              });
            }
          case 'count':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              const [base] = node.args;
              const baseResult = transformGroqToStructure({
                node: base,
                scopes,
                normalizedSchema
              });
              if (!(0, _utils.isStructureArray)(baseResult)) {
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'Number',
                canBeNull: (0, _utils.isStructureNull)(baseResult),
                canBeOptional: false,
                value: null
              });
            }
          case 'defined':
          case 'references':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'Boolean',
                canBeNull: false,
                canBeOptional: false
              });
            }
          case 'identity':
            {
              if (node.args.length) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }

              // https://www.sanity.io/docs/groq-functions#ba5eef75ed4a
              return (0, _utils.createStructure)({
                type: 'String',
                canBeNull: false,
                canBeOptional: false,
                value: null
              });
            }
          case 'length':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              const [base] = node.args;
              const baseResult = transformGroqToStructure({
                node: base,
                scopes,
                normalizedSchema
              });
              if (!(0, _utils.isStructureArray)(baseResult) && !(0, _utils.isStructureString)(baseResult)) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'Number',
                canBeNull: (0, _utils.isStructureNull)(baseResult) || (0, _utils.isStructureOptional)(baseResult),
                canBeOptional: false,
                value: null
              });
            }
          case 'lower':
          case 'upper':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              const [base] = node.args;
              const baseResult = transformGroqToStructure({
                node: base,
                scopes,
                normalizedSchema
              });
              if (!(0, _utils.isStructureString)(baseResult)) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'String',
                canBeNull: (0, _utils.isStructureNull)(baseResult) || (0, _utils.isStructureOptional)(baseResult),
                canBeOptional: false,
                value: baseResult.type !== 'String' ? null : typeof baseResult.value !== 'string' ? null : node.name === 'upper' ? baseResult.value.toUpperCase() : baseResult.value.toLowerCase()
              });
            }
          case 'now':
            {
              if (node.args.length) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'String',
                canBeNull: false,
                canBeOptional: false,
                value: null
              });
            }
          case 'round':
            {
              if (node.args.length <= 0 || node.args.length > 2) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              const [first, second] = node.args.map(n => transformGroqToStructure({
                node: n,
                scopes,
                normalizedSchema
              }));
              if (!(0, _utils.isStructureNumber)(first) && !(0, _utils.isStructureNumber)(second)) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              return (0, _utils.createStructure)({
                type: 'Number',
                canBeNull: (0, _utils.isStructureNull)(first) || (0, _utils.isStructureOptional)(first),
                canBeOptional: false,
                value: null
              });
            }
          default:
            {
              console.warn(`Function "${node.name}" is not currently supported in the given context. Please open an issue.`);
              return (0, _utils.createStructure)({
                type: 'Unknown'
              });
            }
        }
      }
    case 'PipeFuncCall':
      {
        switch (node.name) {
          case 'order':
            {
              const baseResult = transformGroqToStructure({
                node: node.base,
                scopes,
                normalizedSchema
              });
              return baseResult;
            }
          case 'score':
            {
              const baseResult = transformGroqToStructure({
                node: node.base,
                scopes,
                normalizedSchema
              });
              const baseIsArray = (0, _utils.isStructureArray)(baseResult);
              if (!baseIsArray) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              const arrayOf = (0, _utils.unwrapArray)(baseResult);
              if (!(0, _utils.isStructureObject)(arrayOf)) {
                // TODO: warn here
                return (0, _utils.createStructure)({
                  type: 'Unknown'
                });
              }
              const objectWithUnderscoreScore = (0, _utils.createStructure)({
                type: 'Object',
                canBeNull: false,
                canBeOptional: false,
                properties: [{
                  key: '_score',
                  value: (0, _utils.createStructure)({
                    type: 'Number',
                    canBeNull: false,
                    canBeOptional: false,
                    value: null
                  })
                }]
              });
              return (0, _utils.wrapArray)((0, _utils.reduceObjectStructures)(arrayOf, objectWithUnderscoreScore, 'replace'), {
                canBeNull: (0, _utils.isStructureNull)(baseResult),
                canBeOptional: (0, _utils.isStructureOptional)(baseResult)
              });
            }
          default:
            {
              console.warn(`Pipped function "${node.name}" is not currently supported.`);
              return (0, _utils.createStructure)({
                type: 'Unknown'
              });
            }
        }
      }

    // TODO: implement these operators
    case 'Context':
    case 'Selector':
    case 'Tuple':
      {
        console.warn(`"${node.type}" not implemented yet.`);
        return (0, _utils.createStructure)({
          type: 'Unknown'
        });
      }
    default:
      {
        // @ts-expect-error Should never happen because we support all nodes
        console.warn(`"${node.type}" not implemented yet.`);
        return (0, _utils.createStructure)({
          type: 'Unknown'
        });
      }
  }
}