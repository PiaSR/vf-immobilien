"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateSchemaTypes = generateSchemaTypes;
var t = _interopRequireWildcard(require("@babel/types"));
var _defaultGenerateTypeName = require("./default-generate-type-name");
var _transformSchemaToStructure = require("./transform-schema-to-structure");
var _transformStructureToTs = require("./transform-structure-to-ts");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function generateSchemaTypes({
  normalizedSchema
}) {
  // TODO: allow customizing this?
  const workspaceIdentifier = (0, _defaultGenerateTypeName.defaultGenerateTypeName)(normalizedSchema.name);
  const topLevelSchemaNodes = [...normalizedSchema.documents, ...normalizedSchema.registeredTypes];
  const topLevelTypes = topLevelSchemaNodes.map(node => {
    const structure = (0, _transformSchemaToStructure.transformSchemaNodeToStructure)({
      node,
      normalizedSchema
    });

    // TODO: allow customizing this?
    const identifier = (0, _defaultGenerateTypeName.defaultGenerateTypeName)(node.name);
    const {
      tsType,
      declarations,
      substitutions
    } = (0, _transformStructureToTs.transformStructureToTs)({
      structure,
      substitutions: {}
    });
    return {
      structure,
      declarations: {
        ...declarations,
        [structure.hash]: t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Schema'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(identifier), undefined, tsType)]))))
      },
      substitutions: {
        ...substitutions,
        [structure.hash]: t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier(workspaceIdentifier)), t.identifier('Schema')), t.identifier(identifier)))
      }
    };
  });
  const substitutions = Object.fromEntries(topLevelTypes.flatMap(({
    substitutions
  }) => Object.entries(substitutions)));
  const declarations = Object.fromEntries(topLevelTypes.flatMap(({
    declarations
  }) => Object.entries(declarations)));
  return {
    declarations,
    substitutions
  };
}