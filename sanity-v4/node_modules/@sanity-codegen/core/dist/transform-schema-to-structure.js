"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformSchemaNodeToStructure = transformSchemaNodeToStructure;
exports.transformSchemaToStructure = transformSchemaToStructure;
var _defaultStructures = require("./default-structures");
var _geopoint = require("./default-structures/geopoint");
var _utils = require("./utils");
/**
 * Takes in a schema (see the `@sanity-codegen/extractor` package) and
 * returns a `StructureNode`
 */
function transformSchemaToStructure({
  normalizedSchema
}) {
  return (0, _utils.createStructure)({
    type: 'Array',
    of: (0, _utils.createStructure)({
      type: 'Or',
      children: normalizedSchema.documents.map(node => (0, _utils.removeOptional)(transformSchemaNodeToStructure({
        node,
        normalizedSchema
      })))
      // for consistent output
      .sort((a, b) => a.hash.localeCompare(b.hash, 'en'))
    }),
    canBeNull: false,
    canBeOptional: false
  });
}
/**
 * Takes in just one schema node and returns a `StructureNode`
 */
function transformSchemaNodeToStructure({
  node,
  normalizedSchema
}) {
  switch (node.type) {
    case 'RegistryReference':
      {
        const referencedType = [...normalizedSchema.documents, ...normalizedSchema.registeredTypes].find(n => n.name === node.to);

        // TODO: could show warning
        if (!referencedType) return (0, _utils.createStructure)({
          type: 'Unknown'
        });
        return (0, _utils.createStructure)({
          type: 'Lazy',
          // Note that the hash inputs are a function of the resulting getter
          // value. This is necessary to prevent weird caching behavior.
          hashNamespace: 'TransformSchemaToStructure',
          // need to include a schema hash for tests because schemas can have
          // the same referencedType.name and cause unwanted collisions
          hashInput: `${(0, _utils.objectHash)(normalizedSchema)}:${referencedType.name}`,
          get: () => transformSchemaNodeToStructure({
            node: referencedType,
            normalizedSchema
          })
        });
      }
    case 'Array':
      {
        return (0, _utils.createStructure)({
          type: 'Array',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          of: (0, _utils.createStructure)({
            type: 'Or',
            children: node.of.map(node => transformSchemaNodeToStructure({
              node,
              normalizedSchema
            }))
          })
        });
      }
    case 'Block':
      {
        return (0, _utils.createStructure)({
          type: 'Object',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          properties: [{
            key: '_key',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: null
            })
          }, {
            key: '_type',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: 'block'
            })
          }, {
            key: 'children',
            value: (0, _utils.createStructure)({
              type: 'Array',
              canBeNull: false,
              // TODO: can this be marked as false?
              canBeOptional: false,
              of: (0, _utils.createStructure)({
                type: 'Or',
                children: [
                // span
                (0, _utils.createStructure)({
                  type: 'Object',
                  canBeNull: false,
                  canBeOptional: false,
                  properties: [{
                    key: '_key',
                    value: (0, _utils.createStructure)({
                      type: 'String',
                      canBeOptional: false,
                      canBeNull: false,
                      value: null
                    })
                  }, {
                    key: '_type',
                    value: (0, _utils.createStructure)({
                      type: 'String',
                      canBeNull: false,
                      canBeOptional: false,
                      value: 'span'
                    })
                  }, {
                    key: 'marks',
                    value: (0, _utils.createStructure)({
                      type: 'Array',
                      canBeNull: false,
                      canBeOptional: true,
                      of: (0, _utils.createStructure)({
                        type: 'Unknown'
                      })
                    })
                  }, {
                    key: 'text',
                    value: (0, _utils.createStructure)({
                      type: 'String',
                      canBeNull: false,
                      canBeOptional: true,
                      value: null
                    })
                  }]
                }),
                // the rest
                ...(node.of || []).map(child => transformSchemaNodeToStructure({
                  node: child,
                  normalizedSchema
                }))]
              })
            })
          }, {
            key: 'markDefs',
            value: (0, _utils.createStructure)({
              type: 'Array',
              canBeNull: false,
              // TODO: can this be marked as false?
              canBeOptional: true,
              // TODO:
              of: (0, _utils.createStructure)({
                type: 'Unknown'
              })
            })
          }, {
            key: 'style',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              // TODO: can this be marked as false?
              canBeOptional: true,
              value: null
            })
          }]
        });
      }
    case 'Boolean':
      {
        return (0, _utils.createStructure)({
          type: 'Boolean',
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Date':
    case 'Datetime':
    case 'String':
    case 'Text':
    case 'Url':
      {
        return (0, _utils.createStructure)({
          type: 'String',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          value: null
        });
      }
    case 'Object':
    case 'Document':
    case 'File':
    case 'Image':
      {
        const properties = [];
        if (node.type === 'Document') {
          properties.push({
            key: '_type',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: node.name
            })
          });
          properties.push({
            key: '_id',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: null
            })
          });
        }
        if (node.type === 'File') {
          properties.push({
            key: 'asset',
            value: (0, _utils.createStructure)({
              type: 'Reference',
              canBeNull: false,
              canBeOptional: false,
              to: (0, _utils.createStructure)({
                type: 'Unknown'
              })
            })
          });
        }
        if (node.type === 'Image') {
          properties.push({
            key: 'asset',
            value: (0, _utils.createStructure)({
              type: 'Reference',
              canBeNull: false,
              canBeOptional: false,
              to: _defaultStructures.imageAssetStructure
            })
          });
          properties.push({
            key: 'crop',
            value: _defaultStructures.imageCropStructure
          });
          properties.push({
            key: 'hotspot',
            value: _defaultStructures.imageHotspotStructure
          });
        }
        const fieldProperties = node.fields?.map(field => ({
          key: field.name,
          value: transformSchemaNodeToStructure({
            node: field.definition,
            normalizedSchema
          })
        }));
        if (fieldProperties) {
          for (const fieldProperty of fieldProperties) {
            properties.push(fieldProperty);
          }
        }
        return (0, _utils.createStructure)({
          type: 'Object',
          properties,
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Geopoint':
      {
        return (0, _utils.createStructure)({
          ..._geopoint.geopointStructure,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Number':
      {
        return (0, _utils.createStructure)({
          type: 'Number',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          value: null
        });
      }
    case 'Reference':
      {
        return (0, _utils.createStructure)({
          type: 'Reference',
          to: (0, _utils.createStructure)({
            type: 'Or',
            children: node.to.map(node => transformSchemaNodeToStructure({
              node,
              normalizedSchema
            }))
          }),
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Slug':
      {
        return (0, _utils.createStructure)({
          type: 'Object',
          properties: [{
            key: '_type',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: 'slug'
            })
          }, {
            key: 'current',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: !node.codegen.required,
              value: null
            })
          }, {
            key: 'source',
            value: (0, _utils.createStructure)({
              type: 'String',
              canBeNull: false,
              canBeOptional: true,
              value: null
            })
          }],
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    default:
      {
        throw new Error(
        // `schemaDef.type` should be never because we exhausted the list of
        // possible items
        // @ts-expect-error
        `Schema Definition Type "${node.type}" not implemented yet.`);
      }
  }
}