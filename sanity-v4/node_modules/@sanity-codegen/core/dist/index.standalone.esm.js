import hash from 'object-hash';
import * as t from '@babel/types';
import { parse } from 'groq-js';
import chalk from 'chalk';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function replacer(n) {
  // don't consider the contents of the function
  if (typeof n === 'function') {
    // this i just a random string that won't collide with anything
    return 'aaad5ec23bd8c7b1268fb02791c9a19ae1a43abb';
  }
  return n;
}
const objectHashCache = new WeakMap();

/**
 * a very simple object hash function powered by `object-hash`
 */
function objectHash(n) {
  const key = typeof n === 'object' && n ? n : undefined;
  if (key) {
    const cached = objectHashCache.get(key);
    if (cached) return cached;
  }
  const result = hash({
    sanityCodegen: n
  }, {
    algorithm: 'md5',
    replacer,
    encoding: 'base64'
  }).replace(/\W/g, '').substring(0, 16).padStart(16, '0');
  if (key) {
    objectHashCache.set(key, result);
  }
  return result;
}

/**
 * takes any number of items and returns a hash where the top-level order is not
 * considered
 */
function unorderedHash(items) {
  return objectHash({
    sanityCodegenUnordered: items.map(objectHash).sort((a, b) => a.localeCompare(b, 'en'))
  });
}

const _excluded$2 = ["hash"],
  _excluded2 = ["children"],
  _excluded3 = ["of"],
  _excluded4 = ["properties"],
  _excluded5 = ["elements"],
  _excluded6 = ["to"],
  _excluded7 = ["hashInput", "hashNamespace"];

// LazyNode is a special case, see the jsdoc comment below

const memoize = transform => {
  const cache = new Map();
  return node => {
    if (cache.has(node.hash)) return cache.get(node.hash);
    const result = transform(node);
    cache.set(node.hash, result);
    return result;
  };
};
const simplify = memoize(node => {
  if (node.type !== 'And' && node.type !== 'Or') return node;
  const children = Array.from(node.children.map(simplify).reduce((map, child) => {
    if (child.type === node.type) {
      for (const nestedChild of child.children) {
        map.set(nestedChild.hash, nestedChild);
      }
    } else {
      map.set(child.hash, child);
    }
    return map;
  }, new Map()).values()).sort((a, b) => a.hash.localeCompare(b.hash, 'en'));
  if (children.length === 0) return ensureHash({
    type: 'Unknown'
  });
  if (children.length === 1) return children[0];
  return ensureHash(Object.assign({}, node, {
    children
  }));
});
function ensureHash(_ref) {
  let node = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  switch (node.type) {
    case 'And':
    case 'Or':
      {
        const {
            children
          } = node,
          rest = _objectWithoutPropertiesLoose(node, _excluded2);
        return Object.assign({}, node, {
          hash: objectHash([rest, unorderedHash(children.map(i => i.hash))])
        });
      }
    case 'Array':
      {
        const {
            of
          } = node,
          rest = _objectWithoutPropertiesLoose(node, _excluded3);
        return Object.assign({}, node, {
          hash: objectHash([rest, of.hash])
        });
      }
    case 'Object':
      {
        const {
            properties
          } = node,
          rest = _objectWithoutPropertiesLoose(node, _excluded4);
        return Object.assign({}, node, {
          hash: objectHash([rest, unorderedHash(properties.map(i => [i.key, i.value.hash]))])
        });
      }
    case 'Tuple':
      {
        const {
            elements
          } = node,
          rest = _objectWithoutPropertiesLoose(node, _excluded5);
        return Object.assign({}, node, {
          hash: objectHash([rest, elements.map(element => element.hash)])
        });
      }
    case 'Reference':
      {
        const {
            to
          } = node,
          rest = _objectWithoutPropertiesLoose(node, _excluded6);
        return Object.assign({}, node, {
          hash: objectHash([rest, to.hash])
        });
      }
    case 'Unknown':
      {
        return {
          type: 'Unknown',
          hash: 'unknown'
        };
      }
    case 'Lazy':
      {
        const {
            hashInput,
            hashNamespace
          } = node,
          rest = _objectWithoutPropertiesLoose(node, _excluded7);
        return Object.assign({}, rest, {
          hash: objectHash(['Lazy', hashNamespace, hashInput])
        });
      }
    default:
      {
        return Object.assign({}, node, {
          hash: objectHash(node)
        });
      }
  }
}

/**
 * Adds hashes to new `StructureNode`s by looking at the current node's
 * properties. If the node has children (e.g. `And`s/`Or`s), then the hash will
 * use the direct children's hash as an input (this makes all hash computation
 * shallow).
 *
 * The result of this is then ran through `simplify` function memoized by the
 * node's resulting hash.
 *
 * Note: the `LazyNode` is a special case because it's not possible to derive a
 * hash automatically without pulling the lazy value so a `hashNamespace` and
 * a `hashInput` are required.
 */
const createStructure = node => simplify(ensureHash(node));

function createIsStructure({
  accept,
  mode
}) {
  const cache = new Map();
  function is(node, visitedNodes) {
    if (node.type === 'Lazy') {
      const got = node.get();
      if (visitedNodes.has(got.hash)) return false;
      return is(got, new Set([...visitedNodes, got.hash]));
    }
    if (node.type === 'And' || node.type === 'Or') {
      return node.children[mode](child => is(child, visitedNodes));
    }
    return !!accept(node);
  }
  return function isStructure(structure) {
    if (cache.has(structure.hash)) return cache.get(structure.hash);
    const result = is(structure, new Set());
    cache.set(structure.hash, result);
    return result;
  };
}
const isStructureNumber = createIsStructure({
  accept: n => n.type === 'Number',
  mode: 'every'
});
const isStructureString = createIsStructure({
  accept: n => n.type === 'String',
  mode: 'every'
});
const isStructureBoolean = createIsStructure({
  accept: n => n.type === 'Boolean',
  mode: 'every'
});
const isStructureArray = createIsStructure({
  accept: n => ['Array', 'Tuple'].includes(n.type),
  mode: 'every'
});
const isStructureNull = createIsStructure({
  accept: n => n.type === 'Unknown' ? false : n.canBeNull,
  mode: 'some'
});
const isStructureOptional = createIsStructure({
  accept: n => n.type === 'Unknown' ? false : n.canBeOptional,
  mode: 'some'
});
const isStructureObject = createIsStructure({
  accept: n => n.type === 'Object',
  mode: 'every'
});

function createTransform({
  namespace,
  accept = () => true,
  transform: transformLeaf
}) {
  function memoize(fn) {
    const cache = new Map();
    return node => {
      if (cache.has(node.hash)) return cache.get(node.hash);
      const result = fn(node);
      cache.set(node.hash, result);
      return result;
    };
  }
  const transform = memoize(node => {
    if (node.type === 'And' || node.type === 'Or') {
      return createStructure(Object.assign({}, node, {
        children: node.children.map(transform)
      }));
    }
    if (node.type === 'Lazy') {
      return createStructure({
        type: 'Lazy',
        get: () => transform(node.get()),
        hashNamespace: namespace,
        hashInput: node.hash
      });
    }
    if (accept(node)) return transformLeaf(node);
    return node;
  });
  return transform;
}
const addNull = createTransform({
  namespace: 'AddNull',
  accept: node => node.type !== 'Unknown',
  transform: node => createStructure(Object.assign({}, node, {
    canBeNull: true
  }))
});
const addOptional = createTransform({
  namespace: 'AddNull',
  accept: node => node.type !== 'Unknown',
  transform: node => createStructure(Object.assign({}, node, {
    canBeOptional: true
  }))
});
const addOptionalToProperties = createTransform({
  namespace: 'AddOptionalToProperties',
  accept: node => node.type === 'Object',
  transform: node => createStructure({
    type: 'Object',
    canBeNull: node.canBeNull,
    canBeOptional: node.canBeOptional,
    properties: node.properties.map(({
      key,
      value
    }) => ({
      key,
      value: addOptional(value)
    }))
  })
});
const removeOptional = createTransform({
  namespace: 'RemoveOptional',
  accept: node => node.type !== 'Unknown',
  transform: node => createStructure(Object.assign({}, node, {
    canBeOptional: false
  }))
});
const _unwrapArray = createTransform({
  namespace: 'UnwrapArray',
  accept: node => node.type === 'Array' || node.type === 'Tuple',
  transform: node => {
    switch (node.type) {
      case 'Array':
        {
          return node.of;
        }
      case 'Tuple':
        {
          return createStructure({
            type: 'Or',
            children: node.elements
          });
        }
    }
  }
});
const unwrapArray = node => {
  if (!isStructureArray(node)) return node;
  return _unwrapArray(node);
};
const unwrapReferences = createTransform({
  namespace: 'UnwrapReferences',
  accept: node => node.type === 'Reference',
  // this is a bit of a special case since the transform is
  // 1. find reference
  // 2. unwrap one level of lazy
  transform: node => unwrapLazy(node.to)
});
function unwrapLazy(n) {
  switch (n.type) {
    case 'Lazy':
      {
        return n.get();
      }
    case 'And':
    case 'Or':
      {
        return createStructure(Object.assign({}, n, {
          children: n.children.map(unwrapLazy)
        }));
      }
    default:
      {
        return n;
      }
  }
}

function wrapArray(node, options) {
  switch (node.type) {
    case 'And':
    case 'Or':
      {
        return createStructure(Object.assign({}, node, {
          children: node.children.map(child => wrapArray(child, options))
        }));
      }
    case 'Lazy':
      {
        return createStructure({
          type: 'Lazy',
          get: () => wrapArray(node.get(), options),
          hashNamespace: 'WrapArray',
          hashInput: node.hash
        });
      }
    default:
      {
        return createStructure(Object.assign({}, options, {
          type: 'Array',
          of: node
        }));
      }
  }
}

function accessAttributeInStructure(node, attributeName) {
  switch (node.type) {
    case 'And':
    case 'Or':
      {
        return createStructure(Object.assign({}, node, {
          children: node.children.map(child => accessAttributeInStructure(child, attributeName))
        }));
      }
    case 'Object':
      {
        const matchingProperty = node.properties.find(property => property.key === attributeName);
        if (!matchingProperty) return {
          type: 'Unknown',
          hash: 'unknown'
        };
        if (isStructureOptional(matchingProperty.value)) {
          return removeOptional(addNull(matchingProperty.value));
        }
        return matchingProperty.value;
      }
    case 'Array':
      {
        return wrapArray(accessAttributeInStructure(unwrapArray(node.of), attributeName), {
          canBeNull: isStructureNull(node),
          canBeOptional: isStructureOptional(node)
        });
      }
    case 'Lazy':
      {
        return createStructure({
          type: 'Lazy',
          get: () => accessAttributeInStructure(node.get(), attributeName),
          hashNamespace: 'AccessAttributeInStructure',
          hashInput: node.hash
        });
      }
    case 'Reference':
      {
        return accessAttributeInStructure(node.to, attributeName);
      }
    default:
      {
        return {
          type: 'Unknown',
          hash: 'unknown'
        };
      }
  }
}

/**
 * An internal function that takes in an GROQ ExprNode and returns a normalized
 * `LogicExprNode` node used to evaluate against a set of types described by a
 * `StructureNode`
 *
 * @see `accept`
 */
function transformExprNodeToLogicExpr(groqNode) {
  switch (groqNode.type) {
    case 'And':
    case 'Or':
      {
        const children = [transformExprNodeToLogicExpr(groqNode.left), transformExprNodeToLogicExpr(groqNode.right)];
        return {
          type: groqNode.type,
          children,
          hash: objectHash([groqNode.type, unorderedHash(children.map(i => i.hash))])
        };
      }
    case 'Group':
      {
        return transformExprNodeToLogicExpr(groqNode.base);
      }
    case 'Not':
      {
        const child = transformExprNodeToLogicExpr(groqNode.base);
        return {
          type: 'Not',
          child,
          hash: objectHash(['Not', child.hash])
        };
      }
    case 'OpCall':
      {
        switch (groqNode.op) {
          case '!=':
            {
              const child = transformExprNodeToLogicExpr(Object.assign({}, groqNode, {
                op: '=='
              }));
              return {
                type: 'Not',
                child,
                hash: objectHash(['Not', child.hash])
              };
            }
          case '==':
            {
              const variableIdentifierNode = [groqNode.left, groqNode.right].find(n => n.type === 'AccessAttribute');

              // TODO consider this case
              // e.g. `base._type == 'foo'`
              if (variableIdentifierNode !== null && variableIdentifierNode !== void 0 && variableIdentifierNode.base) {
                return {
                  type: 'UnknownExpression',
                  originalExprNode: groqNode,
                  hash: 'unknown'
                };
              }

              // e.g. the `'foo''` of `_type == 'foo'`
              const valueNode = [groqNode.left, groqNode.right].find(n => n.type === 'Value');
              if (variableIdentifierNode && valueNode && (typeof valueNode.value === 'string' || typeof valueNode.value === 'number')) {
                const result = {
                  variable: variableIdentifierNode.name,
                  literal: valueNode.value
                };
                return Object.assign({
                  type: 'SingleVariableEquality'
                }, result, {
                  hash: objectHash(['SingleVariableEquality', result])
                });
              }
              return {
                type: 'UnknownExpression',
                originalExprNode: groqNode,
                hash: 'unknown'
              };
            }
          case 'in':
            {
              if (groqNode.right.type === 'Array') {
                const children = groqNode.right.elements.map(({
                  value,
                  isSplat
                }) => transformExprNodeToLogicExpr(Object.assign({}, groqNode, {
                  op: isSplat ? 'in' : '==',
                  right: value
                })));
                return {
                  type: 'Or',
                  children,
                  hash: objectHash(['Or', unorderedHash(children.map(i => i.hash))])
                };
              }
              return {
                type: 'UnknownExpression',
                originalExprNode: groqNode,
                hash: 'unknown'
              };
            }
          default:
            {
              return {
                type: 'UnknownExpression',
                originalExprNode: groqNode,
                hash: 'unknown'
              };
            }
        }
      }
    case 'Value':
      {
        if (groqNode.value === false) {
          return {
            type: 'Literal',
            hash: 'false',
            value: false
          };
        }
        if (groqNode.value === true) {
          return {
            type: 'Literal',
            hash: 'true',
            value: true
          };
        }
        return {
          type: 'UnknownExpression',
          originalExprNode: groqNode,
          hash: 'unknown'
        };
      }
    default:
      {
        return {
          type: 'UnknownExpression',
          originalExprNode: groqNode,
          hash: 'unknown'
        };
      }
  }
}
const withMemo = fn => {
  const cache = new Map();
  return (node, condition, visitedNodes) => {
    const key = `${node.hash}__${condition.hash}`;
    if (cache.has(key)) return cache.get(key);
    const result = fn(node, condition, visitedNodes);
    cache.set(key, result);
    return result;
  };
};
const accept = withMemo((structure, condition, visitedNodes) => {
  switch (condition.type) {
    case 'And':
      {
        const results = condition.children.map(child => accept(structure, child, visitedNodes));
        let foundUnknown = false;
        for (const result of results) {
          if (result === 'no') return 'no';
          if (result === 'unknown') foundUnknown = true;
        }
        if (foundUnknown) return 'unknown';
        return 'yes';
      }
    case 'Or':
      {
        const results = condition.children.map(child => accept(structure, child, visitedNodes));
        let foundUnknown = false;
        for (const result of results) {
          if (result === 'yes') return 'yes';
          if (result === 'unknown') foundUnknown = true;
        }
        if (foundUnknown) return 'unknown';
        return 'no';
      }
    case 'Not':
      {
        const result = accept(structure, condition.child, visitedNodes);
        if (result === 'yes') return 'no';
        if (result === 'no') return 'yes';
        return 'unknown';
      }
    case 'Literal':
      {
        return condition.value ? 'yes' : 'no';
      }
    case 'SingleVariableEquality':
      {
        switch (structure.type) {
          case 'Lazy':
            {
              const got = structure.get();
              if (visitedNodes.has(got.hash)) return 'no';
              return accept(got, condition, new Set([...visitedNodes, got.hash]));
            }
          case 'And':
            {
              const results = structure.children.map(child => accept(child, condition, visitedNodes));
              for (const result of results) {
                if (result === 'unknown') return 'unknown';
                if (result === 'no') return 'no';
              }
              return 'yes';
            }
          case 'Or':
            {
              const results = structure.children.map(child => accept(child, condition, visitedNodes));
              for (const result of results) {
                if (result === 'unknown') return 'unknown';
                if (result === 'yes') return 'yes';
              }
              return 'no';
            }
          case 'Boolean':
          case 'Number':
          case 'String':
          case 'Tuple':
          case 'Array':
            {
              return 'no';
            }
          case 'Reference':
            {
              // TODO: this could be updated to fallback to an object structure
              // with {_type: 'reference', _ref: string}
              return 'no';
            }
          case 'Object':
            {
              const matchingProperty = structure.properties.find(property => property.key === condition.variable);
              if (!matchingProperty) return 'unknown';
              if ('value' in matchingProperty.value && matchingProperty.value.value === condition.literal) {
                return 'yes';
              }
              return 'no';
            }
          case 'Unknown':
            {
              return 'unknown';
            }
          default:
            {
              // @ts-expect-error
              throw new Error(`${structure.type} not implemented yet`);
            }
        }
      }
    case 'UnknownExpression':
      {
        return 'unknown';
      }
    default:
      {
        // @ts-expect-error
        throw new Error(`${condition.type} not implemented yet`);
      }
  }
});
function narrowOr(node, condition) {
  switch (node.type) {
    case 'Or':
      {
        const result = node.children.filter(child => accept(child, condition, new Set()) !== 'no').map(child => narrowOr(child, condition));
        if (!result.length) {
          return createStructure({
            type: 'Unknown'
          });
        }
        return createStructure({
          type: 'Or',
          children: result
        });
      }
    case 'Lazy':
      {
        return createStructure({
          type: 'Lazy',
          get: () => narrowOr(node.get(), condition),
          hashNamespace: 'NarrowOr',
          hashInput: node.hash
        });
      }
    default:
      {
        switch (accept(node, condition, new Set())) {
          case 'yes':
            return node;
          case 'no':
            return createStructure({
              type: 'Unknown'
            });
          case 'unknown':
            return node;
        }
      }
  }
}
function narrow(node, condition) {
  switch (node.type) {
    case 'Lazy':
      {
        return createStructure({
          type: 'Lazy',
          get: () => narrow(node.get(), condition),
          hashNamespace: 'Narrow',
          hashInput: node.hash
        });
      }
    case 'Or':
      {
        return narrowOr(node, condition);
      }
    case 'And':
      {
        // TODO: should intersections combine object properties?
        return createStructure(Object.assign({}, node, {
          children: node.children.map(n => narrow(n, condition))
        }));
      }
    default:
      {
        switch (accept(node, condition, new Set())) {
          case 'yes':
            return node;
          case 'unknown':
            // benefit of the doubt, leave the node in the structure
            return node;
          case 'no':
            return createStructure({
              type: 'Unknown'
            });
        }
      }
  }
}
function narrowStructure(node, condition) {
  return narrow(node, transformExprNodeToLogicExpr(condition));
}

function reduceObjectStructures(source, incoming, mode) {
  switch (source.type) {
    default:
      {
        throw new Error(`Found unsupported source node type "${source.type}" in ` + `reduceObjectStructures call. Please open an issue.`);
      }

    // TODO: for `And`s, should we combine the objects?
    case 'And':
    case 'Or':
      {
        return createStructure(Object.assign({}, source, {
          children: source.children.map(sourceChild => reduceObjectStructures(sourceChild, incoming, mode))
        }));
      }
    case 'Lazy':
      {
        return createStructure({
          type: 'Lazy',
          hashNamespace: 'ReduceObjectStructuresSource',
          hashInput: source.hash,
          get: () => reduceObjectStructures(source.get(), incoming, mode)
        });
      }
    case 'Object':
      {
        switch (incoming.type) {
          default:
            {
              // TODO: show contextual warning. potentially throw and catch
              // downstream for more context.
              console.warn(`Attempted to use ObjectSplat for unsupported type "${incoming.type}"`);
              return createStructure({
                type: 'Unknown'
              });
            }
          case 'And':
          case 'Or':
            {
              return createStructure(Object.assign({}, incoming, {
                children: incoming.children.map(incomingChild => reduceObjectStructures(source, incomingChild, mode))
              }));
            }
          case 'Lazy':
            {
              return createStructure({
                type: 'Lazy',
                hashNamespace: 'ReduceObjectStructuresIncoming',
                hashInput: incoming.hash,
                get: () => reduceObjectStructures(source, incoming.get(), mode)
              });
            }
          case 'Object':
            {
              const resolvedProperties = mode === 'replace' ? Array.from([...source.properties, ...incoming.properties].reduce((map, property) => {
                map.set(property.key, property);
                return map;
              }, new Map()).values()) : Array.from([...source.properties, ...incoming.properties].reduce((map, property) => {
                const existingProperty = map.get(property.key);
                if (existingProperty) {
                  map.set(property.key, {
                    key: property.key,
                    value: createStructure({
                      type: 'Or',
                      children: [existingProperty.value, property.value]
                    })
                  });
                } else {
                  map.set(property.key, property);
                }
                return map;
              }, new Map()).values());
              return createStructure({
                type: 'Object',
                canBeNull: source.canBeNull || incoming.canBeNull,
                canBeOptional: source.canBeOptional || incoming.canBeOptional,
                properties: resolvedProperties
              });
            }
        }
      }
  }
}

class ResolveExpressionError extends Error {}

const simpleLogger = {
  debug: console.debug.bind(console),
  error: message => console.error(`${chalk.red('✗')} ${message}`),
  info: message => console.info(`${chalk.cyan('ⓘ')} ${message}`),
  log: console.log.bind(console),
  success: message => console.log(`${chalk.green('✓')} ${message}`),
  verbose: message => {
    if (process.env.CI !== 'true') {
      console.log(message);
    }
  },
  warn: message => console.warn(`${chalk.yellow('⚠️')} ${message}`)
};

const imageDimensionsStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: false,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imageDimensions'
    })
  }, {
    key: 'aspectRatio',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'height',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'width',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }]
});
const imagePaletteSwatchStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: false,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imagePaletteSwatch'
    })
  }, {
    key: 'background',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'foreground',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'population',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'title',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }]
});
const imagePaletteStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: false,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imagePalette'
    })
  }, {
    key: 'darkMuted',
    value: imagePaletteSwatchStructure
  }, {
    key: 'darkVibrant',
    value: imagePaletteSwatchStructure
  }, {
    key: 'dominant',
    value: imagePaletteSwatchStructure
  }, {
    key: 'lightMuted',
    value: imagePaletteSwatchStructure
  }, {
    key: 'lightVibrant',
    value: imagePaletteSwatchStructure
  }, {
    key: 'muted',
    value: imagePaletteSwatchStructure
  }, {
    key: 'vibrant',
    value: imagePaletteSwatchStructure
  }]
});
const imageMetadataStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: false,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imageMetadata'
    })
  }, {
    key: 'dimensions',
    value: imageDimensionsStructure
  }, {
    key: 'hasAlpha',
    value: createStructure({
      type: 'Boolean',
      canBeNull: false,
      canBeOptional: false
    })
  }, {
    key: 'isOpaque',
    value: createStructure({
      type: 'Boolean',
      canBeNull: false,
      canBeOptional: false
    })
  }, {
    key: 'lqip',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'palette',
    value: imagePaletteStructure
  }]
});
const imageAssetStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: false,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imageAsset'
    })
  }, {
    key: 'assetId',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'extension',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'metadata',
    value: imageMetadataStructure
  }, {
    key: 'mimeType',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'originalFilename',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'path',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'sha1hash',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'size',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'uploadId',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'url',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }]
});
const imageCropStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: true,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imageCrop'
    })
  }, {
    key: 'bottom',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'left',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'right',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'top',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }]
});
const imageHotspotStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: true,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'sanity.imageHotspot'
    })
  }, {
    key: 'height',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'width',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'x',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'y',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }]
});

const defaultStructures = [imageAssetStructure, imageDimensionsStructure, imageMetadataStructure, imagePaletteStructure, imagePaletteSwatchStructure, imageCropStructure, imageHotspotStructure];

const geopointStructure = createStructure({
  type: 'Object',
  canBeNull: false,
  canBeOptional: true,
  properties: [{
    key: '_type',
    value: createStructure({
      type: 'String',
      canBeNull: false,
      canBeOptional: false,
      value: 'geopoint'
    })
  }, {
    key: 'lat',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'lng',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }, {
    key: 'alt',
    value: createStructure({
      type: 'Number',
      canBeNull: false,
      canBeOptional: false,
      value: null
    })
  }]
});

/**
 * Takes in a schema (see the `@sanity-codegen/extractor` package) and
 * returns a `StructureNode`
 */
function transformSchemaToStructure({
  normalizedSchema
}) {
  return createStructure({
    type: 'Array',
    of: createStructure({
      type: 'Or',
      children: normalizedSchema.documents.map(node => removeOptional(transformSchemaNodeToStructure({
        node,
        normalizedSchema
      })))
      // for consistent output
      .sort((a, b) => a.hash.localeCompare(b.hash, 'en'))
    }),
    canBeNull: false,
    canBeOptional: false
  });
}
/**
 * Takes in just one schema node and returns a `StructureNode`
 */
function transformSchemaNodeToStructure({
  node,
  normalizedSchema
}) {
  switch (node.type) {
    case 'RegistryReference':
      {
        const referencedType = [...normalizedSchema.documents, ...normalizedSchema.registeredTypes].find(n => n.name === node.to);

        // TODO: could show warning
        if (!referencedType) return createStructure({
          type: 'Unknown'
        });
        return createStructure({
          type: 'Lazy',
          // Note that the hash inputs are a function of the resulting getter
          // value. This is necessary to prevent weird caching behavior.
          hashNamespace: 'TransformSchemaToStructure',
          // need to include a schema hash for tests because schemas can have
          // the same referencedType.name and cause unwanted collisions
          hashInput: `${objectHash(normalizedSchema)}:${referencedType.name}`,
          get: () => transformSchemaNodeToStructure({
            node: referencedType,
            normalizedSchema
          })
        });
      }
    case 'Array':
      {
        return createStructure({
          type: 'Array',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          of: createStructure({
            type: 'Or',
            children: node.of.map(node => transformSchemaNodeToStructure({
              node,
              normalizedSchema
            }))
          })
        });
      }
    case 'Block':
      {
        return createStructure({
          type: 'Object',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          properties: [{
            key: '_key',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: null
            })
          }, {
            key: '_type',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: 'block'
            })
          }, {
            key: 'children',
            value: createStructure({
              type: 'Array',
              canBeNull: false,
              // TODO: can this be marked as false?
              canBeOptional: false,
              of: createStructure({
                type: 'Or',
                children: [
                // span
                createStructure({
                  type: 'Object',
                  canBeNull: false,
                  canBeOptional: false,
                  properties: [{
                    key: '_key',
                    value: createStructure({
                      type: 'String',
                      canBeOptional: false,
                      canBeNull: false,
                      value: null
                    })
                  }, {
                    key: '_type',
                    value: createStructure({
                      type: 'String',
                      canBeNull: false,
                      canBeOptional: false,
                      value: 'span'
                    })
                  }, {
                    key: 'marks',
                    value: createStructure({
                      type: 'Array',
                      canBeNull: false,
                      canBeOptional: true,
                      of: createStructure({
                        type: 'Unknown'
                      })
                    })
                  }, {
                    key: 'text',
                    value: createStructure({
                      type: 'String',
                      canBeNull: false,
                      canBeOptional: true,
                      value: null
                    })
                  }]
                }),
                // the rest
                ...(node.of || []).map(child => transformSchemaNodeToStructure({
                  node: child,
                  normalizedSchema
                }))]
              })
            })
          }, {
            key: 'markDefs',
            value: createStructure({
              type: 'Array',
              canBeNull: false,
              // TODO: can this be marked as false?
              canBeOptional: true,
              // TODO:
              of: createStructure({
                type: 'Unknown'
              })
            })
          }, {
            key: 'style',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              // TODO: can this be marked as false?
              canBeOptional: true,
              value: null
            })
          }]
        });
      }
    case 'Boolean':
      {
        return createStructure({
          type: 'Boolean',
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Date':
    case 'Datetime':
    case 'String':
    case 'Text':
    case 'Url':
      {
        return createStructure({
          type: 'String',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          value: null
        });
      }
    case 'Object':
    case 'Document':
    case 'File':
    case 'Image':
      {
        var _node$fields;
        const properties = [];
        if (node.type === 'Document') {
          properties.push({
            key: '_type',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: node.name
            })
          });
          properties.push({
            key: '_id',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: null
            })
          });
        }
        if (node.type === 'File') {
          properties.push({
            key: 'asset',
            value: createStructure({
              type: 'Reference',
              canBeNull: false,
              canBeOptional: false,
              to: createStructure({
                type: 'Unknown'
              })
            })
          });
        }
        if (node.type === 'Image') {
          properties.push({
            key: 'asset',
            value: createStructure({
              type: 'Reference',
              canBeNull: false,
              canBeOptional: false,
              to: imageAssetStructure
            })
          });
          properties.push({
            key: 'crop',
            value: imageCropStructure
          });
          properties.push({
            key: 'hotspot',
            value: imageHotspotStructure
          });
        }
        const fieldProperties = (_node$fields = node.fields) === null || _node$fields === void 0 ? void 0 : _node$fields.map(field => ({
          key: field.name,
          value: transformSchemaNodeToStructure({
            node: field.definition,
            normalizedSchema
          })
        }));
        if (fieldProperties) {
          for (const fieldProperty of fieldProperties) {
            properties.push(fieldProperty);
          }
        }
        return createStructure({
          type: 'Object',
          properties,
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Geopoint':
      {
        return createStructure(Object.assign({}, geopointStructure, {
          canBeOptional: !node.codegen.required
        }));
      }
    case 'Number':
      {
        return createStructure({
          type: 'Number',
          canBeNull: false,
          canBeOptional: !node.codegen.required,
          value: null
        });
      }
    case 'Reference':
      {
        return createStructure({
          type: 'Reference',
          to: createStructure({
            type: 'Or',
            children: node.to.map(node => transformSchemaNodeToStructure({
              node,
              normalizedSchema
            }))
          }),
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    case 'Slug':
      {
        return createStructure({
          type: 'Object',
          properties: [{
            key: '_type',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: false,
              value: 'slug'
            })
          }, {
            key: 'current',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: !node.codegen.required,
              value: null
            })
          }, {
            key: 'source',
            value: createStructure({
              type: 'String',
              canBeNull: false,
              canBeOptional: true,
              value: null
            })
          }],
          canBeNull: false,
          canBeOptional: !node.codegen.required
        });
      }
    default:
      {
        throw new Error(
        // `schemaDef.type` should be never because we exhausted the list of
        // possible items
        // @ts-expect-error
        `Schema Definition Type "${node.type}" not implemented yet.`);
      }
  }
}

/**
 * Used to transform a GROQ AST (e.g. `ExprNode`) into a `StructureNode`
 */
function transformGroqToStructure({
  node,
  normalizedSchema,
  scopes
}) {
  const scope = scopes[scopes.length - 1];
  switch (node.type) {
    case 'Everything':
      {
        return transformSchemaToStructure({
          normalizedSchema: normalizedSchema
        });
      }

    // TODO: are these actually the same?
    case 'Map':
    case 'FlatMap':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        const exprResult = transformGroqToStructure({
          node: node.expr,
          scopes: [...scopes, baseResult],
          normalizedSchema
        });
        return exprResult;
      }
    case 'Filter':
      {
        // e.g. the return type from everything
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (!isStructureArray(baseResult)) {
          // TODO: warn that filter was used on non-array base
          return createStructure({
            type: 'Unknown'
          });
        }
        return wrapArray(narrowStructure(unwrapArray(baseResult), node.expr), {
          canBeOptional: false,
          canBeNull: isStructureNull(baseResult)
        });
      }
    case 'This':
      {
        // TODO: could warn here
        return scope || createStructure({
          type: 'Unknown'
        });
      }
    case 'Parent':
      {
        // TODO: support parent `n` operator
        const parentScope = scopes[scopes.length - 2];
        // TODO: could warn here
        return parentScope || createStructure({
          type: 'Unknown'
        });
      }
    case 'Parameter':
      {
        // Not very easy to know what the intended type of a parameter is so we
        // convert it to `Unknown`. For some cases (such as filtering), this
        // shouldn't have an impact on the resulting types
        return createStructure({
          type: 'Unknown'
        });
      }
    case 'AccessElement':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (baseResult.type === 'Unknown') {
          return createStructure({
            type: 'Unknown'
          });
        }
        return addNull(removeOptional(unwrapArray(baseResult)));
      }
    case 'Projection':
      {
        // e.g. the result of a filter
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        const baseResultHadArray = isStructureArray(baseResult);
        const exprResult = transformGroqToStructure({
          node: node.expr,
          scopes: [...scopes, baseResultHadArray ? unwrapArray(baseResult) : baseResult],
          normalizedSchema
        });
        return baseResultHadArray ? wrapArray(exprResult, {
          canBeNull: isStructureNull(baseResult),
          canBeOptional: isStructureOptional(baseResult)
        }) : exprResult;
      }
    case 'Object':
      {
        if (!node.attributes.length) {
          return createStructure({
            type: 'Unknown'
          });
        }
        const emptyObject = createStructure({
          type: 'Object',
          canBeNull: false,
          canBeOptional: false,
          properties: []
        });
        const combinedObject = node.attributes.reduce((acc, attribute) => {
          switch (attribute.type) {
            case 'ObjectAttributeValue':
              {
                const value = transformGroqToStructure({
                  node: attribute.value,
                  normalizedSchema,
                  scopes
                });
                const singlePropertyObject = createStructure({
                  type: 'Object',
                  canBeNull: false,
                  canBeOptional: false,
                  properties: [{
                    key: attribute.name,
                    value: isStructureOptional(value) ? addNull(removeOptional(value)) : value
                  }]
                });
                return reduceObjectStructures(acc, singlePropertyObject, 'replace');
              }
            case 'ObjectSplat':
              {
                const value = transformGroqToStructure({
                  node: attribute.value,
                  normalizedSchema,
                  scopes
                });
                return reduceObjectStructures(acc, value, 'replace');
              }
            case 'ObjectConditionalSplat':
              {
                const value = transformGroqToStructure({
                  node: attribute.value,
                  scopes,
                  normalizedSchema
                });
                return reduceObjectStructures(acc, addOptionalToProperties(value), 'union');
              }
            default:
              {
                console.warn(
                // @ts-expect-error `attribute` should be of type never
                `Found unsupported object attribute type "${attribute.type}"`);
                return createStructure({
                  type: 'Unknown'
                });
              }
          }
        }, emptyObject);
        return combinedObject;
      }
    case 'Select':
      {
        const children = node.alternatives.map(alternative => transformGroqToStructure({
          node: alternative.value,
          scopes,
          normalizedSchema
        }));
        if (node.fallback) {
          children.push(transformGroqToStructure({
            node: node.fallback,
            scopes,
            normalizedSchema
          }));
        }
        return createStructure({
          type: 'Or',
          children
        });
      }
    case 'Array':
      {
        // if there is a splat in the array literal then…
        if (node.elements.some(element => element.isSplat)) {
          return createStructure({
            // …we can't map to tuple type
            type: 'Array',
            canBeNull: false,
            canBeOptional: false,
            of: createStructure({
              type: 'Or',
              children: node.elements.map(element => {
                if (element.isSplat) {
                  return unwrapArray(transformGroqToStructure({
                    node: element.value,
                    scopes,
                    normalizedSchema
                  }));
                }
                return transformGroqToStructure({
                  node: element.value,
                  scopes,
                  normalizedSchema
                });
              })
            })
          });
        }

        // if there are no splats found, we can list each type out as a tuple
        // to allow for better DX with decomposition
        return createStructure({
          type: 'Tuple',
          canBeNull: false,
          canBeOptional: false,
          elements: node.elements.map(element => transformGroqToStructure({
            node: element.value,
            scopes,
            normalizedSchema
          }))
        });
      }
    case 'AccessAttribute':
      {
        if (node.base) {
          const baseResult = transformGroqToStructure({
            node: node.base,
            scopes: scopes,
            normalizedSchema
          });
          const next = Object.assign({}, node);
          delete next.base;
          return transformGroqToStructure({
            node: next,
            scopes: [...scopes, baseResult],
            normalizedSchema
          });
        }
        if (!scope) return createStructure({
          type: 'Unknown'
        });
        return accessAttributeInStructure(scope, node.name);
      }
    case 'Deref':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        return unwrapReferences(baseResult);
      }
    case 'Slice':
    case 'Group':
    case 'ArrayCoerce':
    case 'Asc':
    case 'Desc':
      {
        return transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
      }
    case 'Value':
      {
        switch (typeof node.value) {
          case 'string':
            {
              return createStructure({
                type: 'String',
                canBeNull: false,
                canBeOptional: false,
                value: node.value
              });
            }
          case 'number':
            {
              return createStructure({
                type: 'Number',
                canBeNull: false,
                canBeOptional: false,
                value: node.value
              });
            }
          case 'boolean':
            {
              return createStructure({
                type: 'Boolean',
                canBeNull: false,
                canBeOptional: false
              });
            }
          default:
            {
              return createStructure({
                type: 'Unknown'
              });
            }
        }
      }
    case 'Or':
    case 'And':
      {
        const leftResult = transformGroqToStructure({
          node: node.left,
          normalizedSchema,
          scopes
        });
        const rightResult = transformGroqToStructure({
          node: node.right,
          normalizedSchema,
          scopes
        });

        // TODO: could warn in these cases
        if (!isStructureBoolean(leftResult)) {
          return createStructure({
            type: 'Unknown'
          });
        }
        if (!isStructureBoolean(rightResult)) {
          return createStructure({
            type: 'Unknown'
          });
        }
        return createStructure({
          type: 'Boolean',
          canBeNull: isStructureNull(leftResult) || isStructureNull(rightResult),
          canBeOptional: isStructureOptional(leftResult) || isStructureOptional(rightResult)
        });
      }
    case 'Not':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (!isStructureBoolean(baseResult)) {
          return createStructure({
            type: 'Unknown'
          });
        }
        return createStructure({
          type: 'Boolean',
          canBeNull: isStructureNull(baseResult),
          canBeOptional: isStructureOptional(baseResult)
        });
      }
    case 'Pos':
    case 'Neg':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        if (!isStructureNumber(baseResult)) {
          return createStructure({
            type: 'Unknown'
          });
        }
        return createStructure({
          type: 'Number',
          canBeNull: isStructureNull(baseResult),
          canBeOptional: isStructureOptional(baseResult),
          value: null
        });
      }
    case 'OpCall':
      {
        const leftStructure = transformGroqToStructure({
          node: node.left,
          scopes,
          normalizedSchema
        });
        const rightStructure = transformGroqToStructure({
          node: node.right,
          scopes,
          normalizedSchema
        });
        const canBeNull = isStructureNull(leftStructure) || isStructureNull(rightStructure);
        const canBeOptional = isStructureOptional(leftStructure) || isStructureOptional(rightStructure);
        switch (node.op) {
          case '*':
          case '**':
          case '-':
          case '/':
          case '%':
            {
              if (!isStructureNumber(leftStructure) || !isStructureNumber(rightStructure)) {
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'Number',
                canBeNull,
                canBeOptional,
                value: null
              });
            }
          case '<=':
          case '<':
          case '>':
          case '>=':
            {
              if (!isStructureNumber(leftStructure) || !isStructureNumber(rightStructure)) {
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'Boolean',
                canBeNull: isStructureNull(leftStructure) || isStructureNull(rightStructure),
                canBeOptional: isStructureOptional(leftStructure) || isStructureOptional(rightStructure)
              });
            }
          case '!=':
          case '==':
          case 'in':
          case 'match':
            {
              return createStructure({
                type: 'Boolean',
                canBeNull: isStructureNull(leftStructure) || isStructureNull(rightStructure),
                canBeOptional: isStructureOptional(leftStructure) || isStructureOptional(rightStructure)
              });
            }
          case '+':
            {
              if (isStructureNumber(leftStructure) && isStructureNumber(rightStructure)) {
                return createStructure({
                  type: 'Number',
                  canBeNull,
                  canBeOptional,
                  value: null
                });
              }
              if (isStructureString(leftStructure) && isStructureString(rightStructure)) {
                const leftStringStructure = leftStructure;
                const rightStringStructure = rightStructure;
                return createStructure({
                  type: 'String',
                  canBeNull,
                  canBeOptional,
                  value: leftStringStructure.value === null ? null : rightStringStructure.value === null ? null : `${leftStringStructure.value}${rightStringStructure.value}`
                });
              }
              return createStructure({
                type: 'Unknown'
              });
            }
          default:
            {
              throw new Error(`Found expected operator "${node.op}". Please open an issue.`);
            }
        }
      }
    case 'InRange':
      {
        const baseResult = transformGroqToStructure({
          node: node.base,
          scopes,
          normalizedSchema
        });
        const leftResult = transformGroqToStructure({
          node: node.left,
          scopes,
          normalizedSchema
        });
        const rightResult = transformGroqToStructure({
          node: node.right,
          scopes,
          normalizedSchema
        });
        if (!isStructureNumber(baseResult)) {
          return createStructure({
            type: 'Unknown'
          });
        }
        return createStructure({
          type: 'Boolean',
          canBeNull: isStructureNull(baseResult) || isStructureNull(leftResult) || isStructureNull(rightResult),
          canBeOptional: isStructureOptional(baseResult) || isStructureOptional(leftResult) || isStructureOptional(rightResult)
        });
      }
    case 'FuncCall':
      {
        switch (node.name) {
          case 'coalesce':
            {
              return createStructure({
                type: 'Or',
                children: node.args.map(arg => transformGroqToStructure({
                  node: arg,
                  scopes,
                  normalizedSchema
                }))
              });
            }
          case 'count':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              const [base] = node.args;
              const baseResult = transformGroqToStructure({
                node: base,
                scopes,
                normalizedSchema
              });
              if (!isStructureArray(baseResult)) {
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'Number',
                canBeNull: isStructureNull(baseResult),
                canBeOptional: false,
                value: null
              });
            }
          case 'defined':
          case 'references':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'Boolean',
                canBeNull: false,
                canBeOptional: false
              });
            }
          case 'identity':
            {
              if (node.args.length) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }

              // https://www.sanity.io/docs/groq-functions#ba5eef75ed4a
              return createStructure({
                type: 'String',
                canBeNull: false,
                canBeOptional: false,
                value: null
              });
            }
          case 'length':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              const [base] = node.args;
              const baseResult = transformGroqToStructure({
                node: base,
                scopes,
                normalizedSchema
              });
              if (!isStructureArray(baseResult) && !isStructureString(baseResult)) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'Number',
                canBeNull: isStructureNull(baseResult) || isStructureOptional(baseResult),
                canBeOptional: false,
                value: null
              });
            }
          case 'lower':
          case 'upper':
            {
              if (node.args.length !== 1) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              const [base] = node.args;
              const baseResult = transformGroqToStructure({
                node: base,
                scopes,
                normalizedSchema
              });
              if (!isStructureString(baseResult)) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'String',
                canBeNull: isStructureNull(baseResult) || isStructureOptional(baseResult),
                canBeOptional: false,
                value: baseResult.type !== 'String' ? null : typeof baseResult.value !== 'string' ? null : node.name === 'upper' ? baseResult.value.toUpperCase() : baseResult.value.toLowerCase()
              });
            }
          case 'now':
            {
              if (node.args.length) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'String',
                canBeNull: false,
                canBeOptional: false,
                value: null
              });
            }
          case 'round':
            {
              if (node.args.length <= 0 || node.args.length > 2) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              const [first, second] = node.args.map(n => transformGroqToStructure({
                node: n,
                scopes,
                normalizedSchema
              }));
              if (!isStructureNumber(first) && !isStructureNumber(second)) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              return createStructure({
                type: 'Number',
                canBeNull: isStructureNull(first) || isStructureOptional(first),
                canBeOptional: false,
                value: null
              });
            }
          default:
            {
              console.warn(`Function "${node.name}" is not currently supported in the given context. Please open an issue.`);
              return createStructure({
                type: 'Unknown'
              });
            }
        }
      }
    case 'PipeFuncCall':
      {
        switch (node.name) {
          case 'order':
            {
              const baseResult = transformGroqToStructure({
                node: node.base,
                scopes,
                normalizedSchema
              });
              return baseResult;
            }
          case 'score':
            {
              const baseResult = transformGroqToStructure({
                node: node.base,
                scopes,
                normalizedSchema
              });
              const baseIsArray = isStructureArray(baseResult);
              if (!baseIsArray) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              const arrayOf = unwrapArray(baseResult);
              if (!isStructureObject(arrayOf)) {
                // TODO: warn here
                return createStructure({
                  type: 'Unknown'
                });
              }
              const objectWithUnderscoreScore = createStructure({
                type: 'Object',
                canBeNull: false,
                canBeOptional: false,
                properties: [{
                  key: '_score',
                  value: createStructure({
                    type: 'Number',
                    canBeNull: false,
                    canBeOptional: false,
                    value: null
                  })
                }]
              });
              return wrapArray(reduceObjectStructures(arrayOf, objectWithUnderscoreScore, 'replace'), {
                canBeNull: isStructureNull(baseResult),
                canBeOptional: isStructureOptional(baseResult)
              });
            }
          default:
            {
              console.warn(`Pipped function "${node.name}" is not currently supported.`);
              return createStructure({
                type: 'Unknown'
              });
            }
        }
      }

    // TODO: implement these operators
    case 'Context':
    case 'Selector':
    case 'Tuple':
      {
        console.warn(`"${node.type}" not implemented yet.`);
        return createStructure({
          type: 'Unknown'
        });
      }
    default:
      {
        // @ts-expect-error Should never happen because we support all nodes
        console.warn(`"${node.type}" not implemented yet.`);
        return createStructure({
          type: 'Unknown'
        });
      }
  }
}

const tsTypeForCircularRefs = node => t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Ref')), t.identifier(`Ref_${node.hash}`)));

/**
 * Takes in a `StructureNode` and returns an object with the resulting main
 * the type, `query`, as well as any named references created (necessary when
 * the schema has self-reference). Those references are stored in an object
 * keyed by that node's hash.
 *
 * The resulting `TSType`s can be printed to source code via `@babel/generator`.
 *
 * @see `generateTypes` for a reference implementation
 */
function transformStructureToTs({
  structure,
  substitutions
}) {
  const lazyNodes = findAllLazyNodes(structure);
  const createAlias = node => {
    const next = n => {
      if (lazyNodes.has(n.hash)) return tsTypeForCircularRefs(n);
      return transform({
        node: n,
        next,
        substitutions
      });
    };

    // purposefully run the transform first before `next`
    return transform({
      node,
      next,
      substitutions
    });
  };
  const aliasTypes = new Map(Array.from(lazyNodes.values()).map(lazyNode => [lazyNode.hash, createAlias(lazyNode)]));
  const next = node => {
    if (aliasTypes.has(node.hash)) return tsTypeForCircularRefs(node);
    return transform({
      node,
      next,
      substitutions
    });
  };
  return {
    tsType: next(structure),
    substitutions: Object.fromEntries(Array.from(aliasTypes).map(([hash]) => [hash, t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Ref')), t.identifier(`Ref_${hash}`)))])),
    declarations: Object.fromEntries(Array.from(aliasTypes).map(([hash, tsType]) => [hash, t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier('Ref'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(`Ref_${hash}`), undefined, tsType)])))]))
  };
}
function findAllLazyNodes(structure) {
  const lazyNodes = new Map();
  function traverse(node) {
    switch (node.type) {
      case 'Lazy':
        {
          if (lazyNodes.has(node.hash)) return;
          lazyNodes.set(node.hash, node);
          traverse(node.get());
          return;
        }
      case 'And':
      case 'Or':
        {
          for (const child of node.children) {
            traverse(child);
          }
          return;
        }
      case 'Object':
        {
          for (const property of node.properties) {
            if (isStructureOptional(property.value)) {
              // this alteration is due to how the transform function below works.
              // if inside an object, a value is found to be optional, the
              // transform removes the optional value and marks the current
              // property as optional instead. this alteration in the tree needs
              // to be accounted for when finding all the lazy nodes
              traverse(removeOptional(property.value));
              continue;
            }
            traverse(property.value);
          }
          return;
        }
      case 'Array':
        {
          // same comment as above
          if (isStructureOptional(node.of)) {
            traverse(removeOptional(node.of));
            return;
          }
          traverse(node.of);
          return;
        }
      case 'Reference':
        {
          traverse(node.to);
          return;
        }
    }
  }
  traverse(structure);
  return lazyNodes;
}
/**
 * Internal transform function that takes in a `StructureNode` and a `next`
 * function and returns a `TSType`.
 *
 * The `next` function is used to intercept the traversal and return different
 * `TSType`s depending on the context
 */
function transform({
  next,
  node,
  substitutions
}) {
  if (substitutions[node.hash]) {
    return substitutions[node.hash];
  }
  let tsType;
  switch (node.type) {
    case 'And':
      {
        tsType = t.tsIntersectionType(node.children.sort((a, b) => a.hash.localeCompare(b.hash, 'en')).map(next));
        break;
      }
    case 'Boolean':
      {
        tsType = t.tsBooleanKeyword();
        break;
      }
    case 'Number':
      {
        tsType = t.tsNumberKeyword();
        break;
      }
    case 'Object':
      {
        tsType = t.tsTypeLiteral(node.properties.sort((a, b) => a.key.localeCompare(b.key, 'en')).map(({
          key,
          value
        }) => {
          const valueIsOptional = isStructureOptional(value);
          const propertySignature = t.tsPropertySignature(t.stringLiteral(key), t.tsTypeAnnotation(next(valueIsOptional ? removeOptional(value) : value)));
          propertySignature.optional = valueIsOptional;
          return propertySignature;
        }));
        break;
      }
    case 'Or':
      {
        tsType = t.tsUnionType(node.children.sort((a, b) => a.hash.localeCompare(b.hash, 'en')).map(next));
        break;
      }
    case 'String':
      {
        tsType = node.value ? t.tsLiteralType(t.stringLiteral(node.value)) : t.tsStringKeyword();
        break;
      }
    case 'Unknown':
      {
        tsType = t.tsUnknownKeyword();
        break;
      }
    case 'Lazy':
      {
        tsType = next(node.get());
        break;
      }
    case 'Reference':
      {
        tsType = t.tsTypeReference(t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Reference')), t.tsTypeParameterInstantiation([next(node.to)]));
        break;
      }
    case 'Array':
      {
        tsType = t.tsArrayType(next(isStructureOptional(node.of) ? removeOptional(node.of) : node.of));
        break;
      }
    case 'Tuple':
      {
        tsType = t.tsTupleType(node.elements.map(next));
        break;
      }
    default:
      {
        // TODO: better comment
        // @ts-expect-error
        throw new Error(node.type);
      }
  }
  if ('canBeNull' in node || 'canBeOptional' in node) {
    const types = [tsType];
    if (node.canBeNull) types.push(t.tsNullKeyword());
    if (node.canBeOptional) types.push(t.tsUndefinedKeyword());
    tsType = t.tsUnionType(types);
  }
  return tsType;
}

function defaultGenerateTypeName(sanityTypeName) {
  const typeName = `${sanityTypeName.substring(0, 1).toUpperCase()}${sanityTypeName
  // If using snake_case, remove underscores and convert to uppercase the letter following them.
  .replace(/(_[A-Z])/gi, replace => replace.substring(1).toUpperCase()).replace(/(-[A-Z])/gi, replace => replace.substring(1).toUpperCase()).replace(/(\.[A-Z])/gi, replace => replace.substring(1).toUpperCase()).substring(1)}`;
  return typeName;
}

const _excluded$1 = ["normalizedSchema", "extractedQueries"];
function generateQueryTypes(_ref) {
  let {
      normalizedSchema,
      extractedQueries
    } = _ref,
    options = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  // TODO: allow customizing this?
  const workspaceIdentifier = defaultGenerateTypeName(normalizedSchema.name);
  const {
    logger = simpleLogger
  } = options;
  const queries = extractedQueries.map(({
    queryKey,
    query
  }) => {
    let structure;
    try {
      structure = transformGroqToStructure({
        node: parse(query),
        scopes: [],
        normalizedSchema
      });
    } catch (e) {
      logger.error(`Failed to parse query \`${queryKey}\`. ${e}`);
      return null;
    }
    const {
      tsType,
      declarations,
      substitutions
    } = transformStructureToTs({
      structure,
      substitutions: options.substitutions
    });
    return {
      structure,
      queryKey,
      declarations: Object.assign({}, declarations, {
        [structure.hash]: t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Query'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(queryKey), undefined, tsType)]))))
      }),
      substitutions: Object.assign({}, substitutions, {
        [structure.hash]: t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier(workspaceIdentifier)), t.identifier('Query')), t.identifier(queryKey)))
      })
    };
  }).filter(t => !!t);
  const substitutions = queries.reduce((acc, {
    queryKey,
    substitutions
  }) => {
    for (const [hash, substitution] of Object.entries(substitutions)) {
      if (!acc[hash]) {
        acc[hash] = substitution;
      } else {
        acc[`${hash}_${queryKey}`] = t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier(workspaceIdentifier)), t.identifier('Query')), t.identifier(queryKey)));
      }
    }
    return acc;
  }, {});
  const declarations = queries.reduce((acc, {
    declarations,
    queryKey,
    structure
  }) => {
    for (const [hash, declaration] of Object.entries(declarations)) {
      if (!acc[hash]) {
        acc[hash] = declaration;
      } else {
        acc[`${hash}_${queryKey}`] = t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Query'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(queryKey), undefined, substitutions[structure.hash])]))));
      }
    }
    return acc;
  }, {});
  const queryKeys = Object.fromEntries(queries.map(i => [i.queryKey, i.structure.hash]));
  return {
    declarations: Object.assign({}, declarations, {
      _ClientConfig: t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Client'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier('Config'), undefined, t.tsTypeLiteral(Object.entries(queryKeys).map(([queryKey, hash]) => {
        return t.tsPropertySignature(t.identifier(queryKey), t.tsTypeAnnotation(substitutions[`${hash}_${queryKey}`] || substitutions[hash]));
      })))]))))
    }),
    substitutions
  };
}

function generateSchemaTypes({
  normalizedSchema
}) {
  // TODO: allow customizing this?
  const workspaceIdentifier = defaultGenerateTypeName(normalizedSchema.name);
  const topLevelSchemaNodes = [...normalizedSchema.documents, ...normalizedSchema.registeredTypes];
  const topLevelTypes = topLevelSchemaNodes.map(node => {
    const structure = transformSchemaNodeToStructure({
      node,
      normalizedSchema
    });

    // TODO: allow customizing this?
    const identifier = defaultGenerateTypeName(node.name);
    const {
      tsType,
      declarations,
      substitutions
    } = transformStructureToTs({
      structure,
      substitutions: {}
    });
    return {
      structure,
      declarations: Object.assign({}, declarations, {
        [structure.hash]: t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Schema'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(identifier), undefined, tsType)]))))
      }),
      substitutions: Object.assign({}, substitutions, {
        [structure.hash]: t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier(workspaceIdentifier)), t.identifier('Schema')), t.identifier(identifier)))
      })
    };
  });
  const substitutions = Object.fromEntries(topLevelTypes.flatMap(({
    substitutions
  }) => Object.entries(substitutions)));
  const declarations = Object.fromEntries(topLevelTypes.flatMap(({
    declarations
  }) => Object.entries(declarations)));
  return {
    declarations,
    substitutions
  };
}

const _excluded = ["name", "title"];

// TODO: utilize this error more and re-hydrate it when it goes over IPC
class SchemaParseError extends Error {}
const getFormattedName = i => {
  if (i.name) return i.name;
  return `(${['anonymous', i.type].filter(Boolean).join(' ')})`;
};
const isRecord = t => {
  if (typeof t !== 'object') return false;
  if (!t) return false;
  return true;
};
function getCommonProps(i, omitOriginalNode) {
  var _i$codegen;
  return Object.assign({
    codegen: {
      required: !!((_i$codegen = i.codegen) !== null && _i$codegen !== void 0 && _i$codegen.required)
    },
    description: i.description || null,
    hidden: !!i.hidden,
    name: i.name || null,
    readOnly: !!i.readOnly,
    title: i.title || (i.name ? transformCamelCase(i.name) : null),
    hasValidation: !!i.validation
  }, !omitOriginalNode && {
    originalNode: i
  });
}
const typeMap = {
  array: 'Array',
  block: 'Block',
  object: 'Object',
  document: 'Document',
  boolean: 'Boolean',
  date: 'Date',
  datetime: 'Datetime',
  geopoint: 'Geopoint',
  slug: 'Slug',
  text: 'Text',
  url: 'Url',
  image: 'Image',
  file: 'File',
  number: 'Number',
  string: 'String',
  reference: 'Reference'
};
function normalizeFields(t, parents, omitOriginalNode) {
  var _t$fields;
  const fields = t.fields || [];
  if (!(t !== null && t !== void 0 && (_t$fields = t.fields) !== null && _t$fields !== void 0 && _t$fields.length)) {
    throw new SchemaParseError(`Expected type \`${parents.join('.')}\` to have property \`fields\` with at least one field.`);
  }
  return fields.map(f => {
    var _f$codegen;
    const pathname = parents.join('.');
    if (typeof f.name !== 'string') {
      throw new SchemaParseError(`\`${pathname}\` had a field missing a \`name\` string.`);
    }
    if (typeof f.type !== 'string') {
      throw new SchemaParseError(`\`${pathname}\` has an invalid \`type\`. Expected a string but got \`${f.type === null ? 'null' : typeof f.type}\``);
    }
    const schemaFieldDef = {
      name: f.name,
      title: f.title || transformCamelCase(f.name),
      description: f.description || '',
      hidden: !!f.hidden,
      readOnly: !!f.readOnly,
      codegen: {
        required: !!((_f$codegen = f.codegen) !== null && _f$codegen !== void 0 && _f$codegen.required)
      },
      hasValidation: !!f.validation,
      definition: normalizeType(f, parents, omitOriginalNode)
    };
    return schemaFieldDef;
  });
}
function normalizeType(t, parents, omitOriginalNode) {
  const pathname = [...parents, getFormattedName(t)].join('.');
  if (!isRecord(t)) {
    throw new SchemaParseError(`Expected \`${pathname}\` to be a non-null object.`);
  }
  if (typeof t.type !== 'string') {
    throw new SchemaParseError(`Expected \`${pathname}.type\` to be a string.`);
  }
  const type = typeMap[t.type] || t.type;
  switch (type) {
    case 'Array':
      {
        const of = t.of;
        if (!of) {
          throw new SchemaParseError(`\`${pathname}\` was of type \`array\` but did not have an \`of\` property.`);
        }
        const schemaArrayDef = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type,
          of: Array.isArray(of) ? of.map((i, index) => normalizeType(i, [...parents, index], omitOriginalNode)) : [normalizeType(of, [...parents, 0], omitOriginalNode)],
          list: normalizeList(t, [...parents, getFormattedName(t)])
        });
        return schemaArrayDef;
      }
    case 'Block':
      {
        const of = t.of;
        const schemaBlockDef = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type,
          of: of ? Array.isArray(of) ? of.map((i, index) => normalizeType(i, [...parents, index], omitOriginalNode)) : [normalizeType(of, [...parents, 0], omitOriginalNode)] : null,
          // TODO: implement this
          markDefs: []
        });
        return schemaBlockDef;
      }
    case 'Object':
      {
        const schemaDef = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type,
          fields: normalizeFields(t, [...parents, getFormattedName(t)], omitOriginalNode)
        });
        return schemaDef;
      }
    case 'Document':
      {
        const _getCommonProps = getCommonProps(t, omitOriginalNode),
          {
            name,
            title
          } = _getCommonProps,
          defProps = _objectWithoutPropertiesLoose(_getCommonProps, _excluded);
        if (!name || typeof name !== 'string') {
          throw new SchemaParseError(`\`name\` is required for documents`);
        }
        if (!title || typeof title !== 'string') {
          throw new SchemaParseError(`\`title\` is required for documents`);
        }
        const schemaDef = Object.assign({}, defProps, {
          name,
          title,
          type,
          fields: normalizeFields(t, [...parents, getFormattedName(t)], omitOriginalNode)
        });
        return schemaDef;
      }
    case 'Boolean':
    case 'Date':
    case 'Datetime':
    case 'Geopoint':
    case 'Slug':
    case 'Text':
    case 'Url':
      {
        const node = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type
        });
        return node;
      }
    case 'Image':
    case 'File':
      {
        const node = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type,
          fields: t.fields ? normalizeFields(t, [...parents, getFormattedName(t)], omitOriginalNode) : null
        });
        return node;
      }
    case 'Number':
    case 'String':
      {
        const node = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type,
          list: normalizeList(t, [...parents, getFormattedName(t)])
        });
        return node;
      }
    case 'Reference':
      {
        // TODO: confirm references are to documents
        const to = t.to;
        if (!to) {
          throw new SchemaParseError(`\`${pathname}\` was of type \`reference\` but did not have an \`to\` property.`);
        }
        const node = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type,
          to: (Array.isArray(to) ? to : [to]).map(i => {
            if (!i.type) {
              throw new SchemaParseError(`\`${pathname}\` of type \`reference\` has a \`to\` value without specifying a \`type\`.`);
            }
            const n = Object.assign({}, getCommonProps(i, omitOriginalNode), {
              to: i.type,
              type: 'RegistryReference'
            });
            return n;
          }),
          weak: !!t.weak
        });
        return node;
      }

    // if not an intrinsic type, then assume it's a registry reference to
    // another type.
    //
    // TODO: confirm this is not an unknown type by checking that a top-level
    // reference does exist
    default:
      {
        const node = Object.assign({}, getCommonProps(t, omitOriginalNode), {
          type: 'RegistryReference',
          to: t.type
        });
        return node;
      }
  }
}
const transformCamelCase = camelCase => {
  const normalizedCamelCase = defaultGenerateTypeName(camelCase);
  return `${normalizedCamelCase.substring(0, 1).toUpperCase()}${normalizedCamelCase.substring(1).replace(/([A-Z])/g, ' $1')}`;
};
function normalizeList(t, parents) {
  var _t$options;
  const list = t === null || t === void 0 ? void 0 : (_t$options = t.options) === null || _t$options === void 0 ? void 0 : _t$options.list;
  const pathname = parents.join('.');
  if (!list) return null;
  if (!Array.isArray(list)) {
    throw new SchemaParseError(`Expected \`${pathname}.options.list\` to be an array but found \`${list === null ? 'null' : typeof list}\` instead.`);
  }
  return list.map(option => {
    if (typeof option === 'string') {
      return {
        title: transformCamelCase(option),
        value: option
      };
    }
    if (typeof option === 'number') {
      return {
        title: option.toString(),
        value: option
      };
    }
    if (typeof option !== 'object') {
      throw new SchemaParseError(`Invalid \`options.list\` item for type \`${pathname}\`. Expected a string, number, or object but found "${option === null ? 'null' : typeof option}"`);
    }
    if (!('title' in option && 'value' in option)) {
      throw new SchemaParseError(`Invalid \`options.list\` item for type \`${pathname}\`. Expected item to have properties \`title\` and \`value\`.`);
    }
    return {
      title: option.title,
      value: option.value
    };
  });
}
/**
 * Takes in a raw sanity schema and returns a statically typed normalized
 * version. This function also validates the raw schema, throwing when errors
 * are found.
 *
 * @param types raw sanity schema in the form of a type array
 * @returns normalized sanity schema
 */
// TODO: refactor this API to take in a config object instead of a single argument
function schemaNormalizer({
  name,
  types,
  omitOriginalNode = false
}) {
  if (!name) {
    throw new SchemaParseError('No name was provided alongside a schema.');
  }
  const allRegisteredTypes = types.map(i => normalizeType(i, [], omitOriginalNode));

  // TODO: check if name is trying to override primitive types
  for (const registeredType of allRegisteredTypes) {
    if (!registeredType.name) {
      throw new SchemaParseError('Found top-level registered type with no `name` field.');
    }
  }
  const documents = allRegisteredTypes.filter(n => n.type === 'Document');
  const restOfRegisteredTypes = allRegisteredTypes.filter(n => n.type !== 'Document');
  return {
    name,
    type: 'SchemaRoot',
    documents,
    registeredTypes: restOfRegisteredTypes
  };

  // TODO: run validation afterwards
}

export { ResolveExpressionError, SchemaParseError, defaultStructures, generateQueryTypes, generateSchemaTypes, schemaNormalizer, transformGroqToStructure, transformSchemaToStructure, transformStructureToTs };
//# sourceMappingURL=index.standalone.esm.js.map
