{"version":3,"file":"index.standalone.cjs.js","sources":["../src/utils/hash.ts","../src/utils/create-structure.ts","../src/utils/is-structure.ts","../src/utils/transforms.ts","../src/utils/wrap-array.ts","../src/utils/access-attribute-in-structure.ts","../src/utils/narrow-structure.ts","../src/utils/reduce-object-structures.ts","../src/resolve-expression-error.ts","../src/utils/simple-logger.ts","../src/default-structures/image.ts","../src/default-structures/index.ts","../src/default-structures/geopoint.ts","../src/transform-schema-to-structure.ts","../src/transform-groq-to-structure.ts","../src/transform-structure-to-ts.ts","../src/default-generate-type-name.ts","../src/generate-query-types.ts","../src/generate-schema-types.ts","../src/schema-normalizer.ts"],"sourcesContent":["import hash from 'object-hash';\n\nfunction replacer(n: unknown) {\n  // don't consider the contents of the function\n  if (typeof n === 'function') {\n    // this i just a random string that won't collide with anything\n    return 'aaad5ec23bd8c7b1268fb02791c9a19ae1a43abb';\n  }\n\n  return n;\n}\n\nconst objectHashCache = new WeakMap<object, string>();\n\n/**\n * a very simple object hash function powered by `object-hash`\n */\nexport function objectHash(n: unknown) {\n  const key = typeof n === 'object' && n ? n : undefined;\n\n  if (key) {\n    const cached = objectHashCache.get(key);\n    if (cached) return cached;\n  }\n\n  const result = hash(\n    { sanityCodegen: n },\n    { algorithm: 'md5', replacer, encoding: 'base64' },\n  )\n    .replace(/\\W/g, '')\n    .substring(0, 16)\n    .padStart(16, '0');\n\n  if (key) {\n    objectHashCache.set(key, result);\n  }\n\n  return result;\n}\n\n/**\n * takes any number of items and returns a hash where the top-level order is not\n * considered\n */\nexport function unorderedHash(items: unknown[]) {\n  return objectHash({\n    sanityCodegenUnordered: items\n      .map(objectHash)\n      .sort((a, b) => a.localeCompare(b, 'en')),\n  });\n}\n","import { unorderedHash, objectHash } from './hash';\n\n// LazyNode is a special case, see the jsdoc comment below\ntype LazyNodeWithoutHash = Omit<Sanity.GroqCodegen.LazyNode, 'hash'> & {\n  hashNamespace: string;\n  hashInput: string;\n};\n\ntype StructureNodeTypes = Exclude<\n  Sanity.GroqCodegen.StructureNode['type'],\n  // LazyNode is a special case, see the jsdoc comment below\n  'Lazy'\n>;\n\n// creates a type of all the `StructureNode`s but without a hash\ntype StructureNodeWithoutHash = {\n  [P in StructureNodeTypes]: Omit<\n    Extract<Sanity.GroqCodegen.StructureNode, { type: P }>,\n    'hash'\n  >;\n}[StructureNodeTypes];\n\ntype InputNode = (StructureNodeWithoutHash | LazyNodeWithoutHash) & {\n  // adds in `hash` as an optional string for easier use however any\n  // pre-existing hashes will be overridden\n  hash?: string;\n};\n\ntype Transform = (\n  node: Sanity.GroqCodegen.StructureNode,\n) => Sanity.GroqCodegen.StructureNode;\n\nconst memoize = (transform: Transform): Transform => {\n  const cache = new Map<string, Sanity.GroqCodegen.StructureNode>();\n\n  return (node) => {\n    if (cache.has(node.hash)) return cache.get(node.hash)!;\n    const result = transform(node);\n    cache.set(node.hash, result);\n    return result;\n  };\n};\n\nexport const simplify = memoize((node: Sanity.GroqCodegen.StructureNode) => {\n  if (node.type !== 'And' && node.type !== 'Or') return node;\n\n  const children = Array.from(\n    node.children\n      .map(simplify)\n      .reduce<Map<string, Sanity.GroqCodegen.StructureNode>>((map, child) => {\n        if (child.type === node.type) {\n          for (const nestedChild of child.children) {\n            map.set(nestedChild.hash, nestedChild);\n          }\n        } else {\n          map.set(child.hash, child);\n        }\n        return map;\n      }, new Map())\n      .values(),\n  ).sort((a, b) => a.hash.localeCompare(b.hash, 'en'));\n\n  if (children.length === 0) return ensureHash({ type: 'Unknown' });\n  if (children.length === 1) return children[0];\n  return ensureHash({ ...node, children });\n});\n\nfunction ensureHash({\n  // remove an pre-existing hash\n  hash: _hash,\n  ...node\n}: InputNode): Sanity.GroqCodegen.StructureNode {\n  switch (node.type) {\n    case 'And':\n    case 'Or': {\n      const { children, ...rest } = node;\n      return {\n        ...node,\n        hash: objectHash([rest, unorderedHash(children.map((i) => i.hash))]),\n      };\n    }\n    case 'Array': {\n      const { of, ...rest } = node;\n      return {\n        ...node,\n        hash: objectHash([rest, of.hash]),\n      };\n    }\n    case 'Object': {\n      const { properties, ...rest } = node;\n      return {\n        ...node,\n        hash: objectHash([\n          rest,\n          unorderedHash(properties.map((i) => [i.key, i.value.hash])),\n        ]),\n      };\n    }\n    case 'Tuple': {\n      const { elements, ...rest } = node;\n      return {\n        ...node,\n        hash: objectHash([rest, elements.map((element) => element.hash)]),\n      };\n    }\n    case 'Reference': {\n      const { to, ...rest } = node;\n      return {\n        ...node,\n        hash: objectHash([rest, to.hash]),\n      };\n    }\n    case 'Unknown': {\n      return { type: 'Unknown', hash: 'unknown' };\n    }\n    case 'Lazy': {\n      const { hashInput, hashNamespace, ...rest } = node;\n      return {\n        // this is `rest` on purpose\n        ...rest,\n        hash: objectHash(['Lazy', hashNamespace, hashInput]),\n      };\n    }\n    default: {\n      return {\n        ...node,\n        hash: objectHash(node),\n      };\n    }\n  }\n}\n\n/**\n * Adds hashes to new `StructureNode`s by looking at the current node's\n * properties. If the node has children (e.g. `And`s/`Or`s), then the hash will\n * use the direct children's hash as an input (this makes all hash computation\n * shallow).\n *\n * The result of this is then ran through `simplify` function memoized by the\n * node's resulting hash.\n *\n * Note: the `LazyNode` is a special case because it's not possible to derive a\n * hash automatically without pulling the lazy value so a `hashNamespace` and\n * a `hashInput` are required.\n */\nexport const createStructure = (node: InputNode) => simplify(ensureHash(node));\n","interface Params {\n  accept: (\n    node: Exclude<\n      Sanity.GroqCodegen.StructureNode,\n      { type: 'And' | 'Or' | 'Lazy' }\n    >,\n  ) => boolean | undefined | null;\n  mode: 'some' | 'every';\n}\n\nfunction createIsStructure({ accept, mode }: Params) {\n  const cache = new Map<string, boolean>();\n\n  function is(\n    node: Sanity.GroqCodegen.StructureNode,\n    visitedNodes: Set<string>,\n  ): boolean {\n    if (node.type === 'Lazy') {\n      const got = node.get();\n      if (visitedNodes.has(got.hash)) return false;\n      return is(got, new Set([...visitedNodes, got.hash]));\n    }\n\n    if (node.type === 'And' || node.type === 'Or') {\n      return node.children[mode]((child) => is(child, visitedNodes));\n    }\n\n    return !!accept(node);\n  }\n\n  return function isStructure(structure: Sanity.GroqCodegen.StructureNode) {\n    if (cache.has(structure.hash)) return cache.get(structure.hash)!;\n    const result = is(structure, new Set());\n\n    cache.set(structure.hash, result);\n    return result;\n  };\n}\n\nexport const isStructureNumber = createIsStructure({\n  accept: (n) => n.type === 'Number',\n  mode: 'every',\n});\n\nexport const isStructureString = createIsStructure({\n  accept: (n) => n.type === 'String',\n  mode: 'every',\n});\n\nexport const isStructureBoolean = createIsStructure({\n  accept: (n) => n.type === 'Boolean',\n  mode: 'every',\n});\n\nexport const isStructureArray = createIsStructure({\n  accept: (n) => ['Array', 'Tuple'].includes(n.type),\n  mode: 'every',\n});\n\nexport const isStructureNull = createIsStructure({\n  accept: (n) => (n.type === 'Unknown' ? false : n.canBeNull),\n  mode: 'some',\n});\n\nexport const isStructureOptional = createIsStructure({\n  accept: (n) => (n.type === 'Unknown' ? false : n.canBeOptional),\n  mode: 'some',\n});\n\nexport const isStructureObject = createIsStructure({\n  accept: (n) => n.type === 'Object',\n  mode: 'every',\n});\n","import { createStructure } from './create-structure';\nimport { isStructureArray } from './is-structure';\n\ntype StructureNode = Sanity.GroqCodegen.StructureNode;\ntype LeafNode = Exclude<StructureNode, { type: 'And' | 'Or' | 'Lazy' }>;\n\ninterface Params<R extends LeafNode> {\n  namespace: string;\n  accept?: (node: LeafNode) => boolean;\n  transform: (node: R) => StructureNode;\n}\n\nexport function createTransform<R extends LeafNode>({\n  namespace,\n  accept = () => true,\n  transform: transformLeaf,\n}: Params<R>): (node: StructureNode) => StructureNode {\n  function memoize(fn: (node: StructureNode) => StructureNode) {\n    const cache = new Map<string, StructureNode>();\n\n    return (node: StructureNode) => {\n      if (cache.has(node.hash)) return cache.get(node.hash)!;\n      const result = fn(node);\n      cache.set(node.hash, result);\n      return result;\n    };\n  }\n\n  const transform = memoize((node) => {\n    if (node.type === 'And' || node.type === 'Or') {\n      return createStructure({\n        ...node,\n        children: node.children.map(transform),\n      });\n    }\n\n    if (node.type === 'Lazy') {\n      return createStructure({\n        type: 'Lazy',\n        get: () => transform(node.get()),\n        hashNamespace: namespace,\n        hashInput: node.hash,\n      });\n    }\n\n    if (accept(node)) return transformLeaf(node as R);\n    return node;\n  });\n\n  return transform;\n}\n\nexport const addNull = createTransform({\n  namespace: 'AddNull',\n  accept: (node) => node.type !== 'Unknown',\n  transform: (node) => createStructure({ ...node, canBeNull: true }),\n});\n\nexport const addOptional = createTransform({\n  namespace: 'AddNull',\n  accept: (node) => node.type !== 'Unknown',\n  transform: (node) => createStructure({ ...node, canBeOptional: true }),\n});\n\nexport const addOptionalToProperties = createTransform<\n  Extract<LeafNode, { type: 'Object' }>\n>({\n  namespace: 'AddOptionalToProperties',\n  accept: (node) => node.type === 'Object',\n  transform: (node) =>\n    createStructure({\n      type: 'Object',\n      canBeNull: node.canBeNull,\n      canBeOptional: node.canBeOptional,\n      properties: node.properties.map(({ key, value }) => ({\n        key,\n        value: addOptional(value),\n      })),\n    }),\n});\n\nexport const removeOptional = createTransform({\n  namespace: 'RemoveOptional',\n  accept: (node) => node.type !== 'Unknown',\n  transform: (node) => createStructure({ ...node, canBeOptional: false }),\n});\n\nconst _unwrapArray = createTransform<\n  Extract<LeafNode, { type: 'Array' | 'Tuple' }>\n>({\n  namespace: 'UnwrapArray',\n  accept: (node) => node.type === 'Array' || node.type === 'Tuple',\n  transform: (node) => {\n    switch (node.type) {\n      case 'Array': {\n        return node.of;\n      }\n      case 'Tuple': {\n        return createStructure({ type: 'Or', children: node.elements });\n      }\n    }\n  },\n});\n\nexport const unwrapArray = (node: StructureNode) => {\n  if (!isStructureArray(node)) return node;\n  return _unwrapArray(node);\n};\n\nexport const unwrapReferences = createTransform<\n  Extract<LeafNode, { type: 'Reference' }>\n>({\n  namespace: 'UnwrapReferences',\n  accept: (node) => node.type === 'Reference',\n  // this is a bit of a special case since the transform is\n  // 1. find reference\n  // 2. unwrap one level of lazy\n  transform: (node) => unwrapLazy(node.to),\n});\n\nfunction unwrapLazy(n: StructureNode): StructureNode {\n  switch (n.type) {\n    case 'Lazy': {\n      return n.get();\n    }\n    case 'And':\n    case 'Or': {\n      return createStructure({\n        ...n,\n        children: n.children.map(unwrapLazy),\n      });\n    }\n    default: {\n      return n;\n    }\n  }\n}\n","import { createStructure } from './create-structure';\n\nexport function wrapArray(\n  node: Sanity.GroqCodegen.StructureNode,\n  options: { canBeNull: boolean; canBeOptional: boolean },\n): Sanity.GroqCodegen.StructureNode {\n  switch (node.type) {\n    case 'And':\n    case 'Or': {\n      return createStructure({\n        ...node,\n        children: node.children.map((child) => wrapArray(child, options)),\n      });\n    }\n    case 'Lazy': {\n      return createStructure({\n        type: 'Lazy',\n        get: () => wrapArray(node.get(), options),\n        hashNamespace: 'WrapArray',\n        hashInput: node.hash,\n      });\n    }\n    default: {\n      return createStructure({\n        ...options,\n        type: 'Array',\n        of: node,\n      });\n    }\n  }\n}\n","import { createStructure } from './create-structure';\nimport { isStructureNull, isStructureOptional } from './is-structure';\nimport { addNull, unwrapArray, removeOptional } from './transforms';\nimport { wrapArray } from './wrap-array';\n\nexport function accessAttributeInStructure(\n  node: Sanity.GroqCodegen.StructureNode,\n  attributeName: string,\n): Sanity.GroqCodegen.StructureNode {\n  switch (node.type) {\n    case 'And':\n    case 'Or': {\n      return createStructure({\n        ...node,\n        children: node.children.map((child) =>\n          accessAttributeInStructure(child, attributeName),\n        ),\n      });\n    }\n\n    case 'Object': {\n      const matchingProperty = node.properties.find(\n        (property) => property.key === attributeName,\n      );\n\n      if (!matchingProperty) return { type: 'Unknown', hash: 'unknown' };\n\n      if (isStructureOptional(matchingProperty.value)) {\n        return removeOptional(addNull(matchingProperty.value));\n      }\n\n      return matchingProperty.value;\n    }\n    case 'Array': {\n      return wrapArray(\n        accessAttributeInStructure(unwrapArray(node.of), attributeName),\n        {\n          canBeNull: isStructureNull(node),\n          canBeOptional: isStructureOptional(node),\n        },\n      );\n    }\n    case 'Lazy': {\n      return createStructure({\n        type: 'Lazy',\n        get: () => accessAttributeInStructure(node.get(), attributeName),\n        hashNamespace: 'AccessAttributeInStructure',\n        hashInput: node.hash,\n      });\n    }\n    case 'Reference': {\n      return accessAttributeInStructure(node.to, attributeName);\n    }\n    default: {\n      return { type: 'Unknown', hash: 'unknown' };\n    }\n  }\n}\n","import type { parse } from 'groq-js';\nimport { createStructure } from './create-structure';\nimport { objectHash, unorderedHash } from './hash';\n\ntype ExprNode = ReturnType<typeof parse>;\n\n// TODO: could include things like defined checks or narrow based on types\n// TODO: also think about functions and how they could affect narrowing\n//\n// e.g. _type == 'foo' && defined(bar) would not accept structure nodes that\n// don't `bar` and could mark `bar` as `canBeNull: false`\n//\n// e.g. description == 'hello' would not accept structure nodes that have the\n// type of description as `number`\ntype LogicExprNode =\n  | { type: 'And'; children: LogicExprNode[]; hash: string }\n  | { type: 'Or'; children: LogicExprNode[]; hash: string }\n  | { type: 'Not'; child: LogicExprNode; hash: string }\n  | { type: 'Literal'; value: boolean; hash: 'true' | 'false' }\n  | {\n      type: 'SingleVariableEquality';\n      variable: string;\n      literal: string | number;\n      hash: string;\n    }\n  | {\n      type: 'UnknownExpression';\n      originalExprNode: ExprNode;\n      hash: 'unknown';\n    };\n\n/**\n * An internal function that takes in an GROQ ExprNode and returns a normalized\n * `LogicExprNode` node used to evaluate against a set of types described by a\n * `StructureNode`\n *\n * @see `accept`\n */\nexport function transformExprNodeToLogicExpr(\n  groqNode: ExprNode,\n): LogicExprNode {\n  switch (groqNode.type) {\n    case 'And':\n    case 'Or': {\n      const children = [\n        transformExprNodeToLogicExpr(groqNode.left),\n        transformExprNodeToLogicExpr(groqNode.right),\n      ];\n      return {\n        type: groqNode.type,\n        children,\n        hash: objectHash([\n          groqNode.type,\n          unorderedHash(children.map((i) => i.hash)),\n        ]),\n      };\n    }\n\n    case 'Group': {\n      return transformExprNodeToLogicExpr(groqNode.base);\n    }\n\n    case 'Not': {\n      const child = transformExprNodeToLogicExpr(groqNode.base);\n      return {\n        type: 'Not',\n        child,\n        hash: objectHash(['Not', child.hash]),\n      };\n    }\n\n    case 'OpCall': {\n      switch (groqNode.op) {\n        case '!=': {\n          const child = transformExprNodeToLogicExpr({ ...groqNode, op: '==' });\n          return {\n            type: 'Not',\n            child,\n            hash: objectHash(['Not', child.hash]),\n          };\n        }\n        case '==': {\n          const variableIdentifierNode = [groqNode.left, groqNode.right].find(\n            (n): n is Extract<ExprNode, { type: 'AccessAttribute' }> =>\n              n.type === 'AccessAttribute',\n          );\n\n          // TODO consider this case\n          // e.g. `base._type == 'foo'`\n          if (variableIdentifierNode?.base) {\n            return {\n              type: 'UnknownExpression',\n              originalExprNode: groqNode,\n              hash: 'unknown',\n            };\n          }\n\n          // e.g. the `'foo''` of `_type == 'foo'`\n          const valueNode = [groqNode.left, groqNode.right].find(\n            (n): n is Extract<ExprNode, { type: 'Value' }> =>\n              n.type === 'Value',\n          );\n\n          if (\n            variableIdentifierNode &&\n            valueNode &&\n            (typeof valueNode.value === 'string' ||\n              typeof valueNode.value === 'number')\n          ) {\n            const result = {\n              variable: variableIdentifierNode.name,\n              literal: valueNode.value,\n            };\n\n            return {\n              type: 'SingleVariableEquality',\n              ...result,\n              hash: objectHash(['SingleVariableEquality', result]),\n            };\n          }\n\n          return {\n            type: 'UnknownExpression',\n            originalExprNode: groqNode,\n            hash: 'unknown',\n          };\n        }\n\n        case 'in': {\n          if (groqNode.right.type === 'Array') {\n            const children = groqNode.right.elements.map(({ value, isSplat }) =>\n              transformExprNodeToLogicExpr({\n                ...groqNode,\n                op: isSplat ? 'in' : '==',\n                right: value,\n              }),\n            );\n\n            return {\n              type: 'Or',\n              children,\n              hash: objectHash([\n                'Or',\n                unorderedHash(children.map((i) => i.hash)),\n              ]),\n            };\n          }\n\n          return {\n            type: 'UnknownExpression',\n            originalExprNode: groqNode,\n            hash: 'unknown',\n          };\n        }\n\n        default: {\n          return {\n            type: 'UnknownExpression',\n            originalExprNode: groqNode,\n            hash: 'unknown',\n          };\n        }\n      }\n    }\n\n    case 'Value': {\n      if (groqNode.value === false) {\n        return {\n          type: 'Literal',\n          hash: 'false',\n          value: false,\n        };\n      }\n\n      if (groqNode.value === true) {\n        return {\n          type: 'Literal',\n          hash: 'true',\n          value: true,\n        };\n      }\n\n      return {\n        type: 'UnknownExpression',\n        originalExprNode: groqNode,\n        hash: 'unknown',\n      };\n    }\n\n    default: {\n      return {\n        type: 'UnknownExpression',\n        originalExprNode: groqNode,\n        hash: 'unknown',\n      };\n    }\n  }\n}\n\nconst withMemo = <\n  Fn extends (\n    node: Sanity.GroqCodegen.StructureNode,\n    condition: LogicExprNode,\n    visitedNodes: Set<string>,\n  ) => any,\n>(\n  fn: Fn,\n): Fn => {\n  const cache = new Map<string, any>();\n\n  return ((node, condition, visitedNodes) => {\n    const key = `${node.hash}__${condition.hash}`;\n    if (cache.has(key)) return cache.get(key);\n\n    const result = fn(node, condition, visitedNodes);\n    cache.set(key, result);\n    return result;\n  }) as Fn;\n};\n\nexport const accept = withMemo(\n  (structure, condition, visitedNodes): 'yes' | 'no' | 'unknown' => {\n    switch (condition.type) {\n      case 'And': {\n        const results = condition.children.map((child) =>\n          accept(structure, child, visitedNodes),\n        );\n\n        let foundUnknown = false;\n        for (const result of results) {\n          if (result === 'no') return 'no';\n          if (result === 'unknown') foundUnknown = true;\n        }\n        if (foundUnknown) return 'unknown';\n        return 'yes';\n      }\n      case 'Or': {\n        const results = condition.children.map((child) =>\n          accept(structure, child, visitedNodes),\n        );\n\n        let foundUnknown = false;\n        for (const result of results) {\n          if (result === 'yes') return 'yes';\n          if (result === 'unknown') foundUnknown = true;\n        }\n        if (foundUnknown) return 'unknown';\n        return 'no';\n      }\n      case 'Not': {\n        const result = accept(structure, condition.child, visitedNodes);\n        if (result === 'yes') return 'no';\n        if (result === 'no') return 'yes';\n        return 'unknown';\n      }\n      case 'Literal': {\n        return condition.value ? 'yes' : 'no';\n      }\n      case 'SingleVariableEquality': {\n        switch (structure.type) {\n          case 'Lazy': {\n            const got = structure.get();\n            if (visitedNodes.has(got.hash)) return 'no';\n            return accept(got, condition, new Set([...visitedNodes, got.hash]));\n          }\n          case 'And': {\n            const results = structure.children.map((child) =>\n              accept(child, condition, visitedNodes),\n            );\n\n            for (const result of results) {\n              if (result === 'unknown') return 'unknown';\n              if (result === 'no') return 'no';\n            }\n\n            return 'yes';\n          }\n          case 'Or': {\n            const results = structure.children.map((child) =>\n              accept(child, condition, visitedNodes),\n            );\n\n            for (const result of results) {\n              if (result === 'unknown') return 'unknown';\n              if (result === 'yes') return 'yes';\n            }\n\n            return 'no';\n          }\n          case 'Boolean':\n          case 'Number':\n          case 'String':\n          case 'Tuple':\n          case 'Array': {\n            return 'no';\n          }\n          case 'Reference': {\n            // TODO: this could be updated to fallback to an object structure\n            // with {_type: 'reference', _ref: string}\n            return 'no';\n          }\n          case 'Object': {\n            const matchingProperty = structure.properties.find(\n              (property) => property.key === condition.variable,\n            );\n\n            if (!matchingProperty) return 'unknown';\n\n            if (\n              'value' in matchingProperty.value &&\n              matchingProperty.value.value === condition.literal\n            ) {\n              return 'yes';\n            }\n\n            return 'no';\n          }\n          case 'Unknown': {\n            return 'unknown';\n          }\n          default: {\n            // @ts-expect-error\n            throw new Error(`${structure.type} not implemented yet`);\n          }\n        }\n      }\n\n      case 'UnknownExpression': {\n        return 'unknown';\n      }\n\n      default: {\n        // @ts-expect-error\n        throw new Error(`${condition.type} not implemented yet`);\n      }\n    }\n  },\n);\n\nfunction narrowOr(\n  node: Sanity.GroqCodegen.StructureNode,\n  condition: LogicExprNode,\n): Sanity.GroqCodegen.StructureNode {\n  switch (node.type) {\n    case 'Or': {\n      const result = node.children\n        .filter((child) => accept(child, condition, new Set()) !== 'no')\n        .map((child) => narrowOr(child, condition));\n\n      if (!result.length) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return createStructure({ type: 'Or', children: result });\n    }\n    case 'Lazy': {\n      return createStructure({\n        type: 'Lazy',\n        get: () => narrowOr(node.get(), condition),\n        hashNamespace: 'NarrowOr',\n        hashInput: node.hash,\n      });\n    }\n    default: {\n      switch (accept(node, condition, new Set())) {\n        case 'yes':\n          return node;\n        case 'no':\n          return createStructure({ type: 'Unknown' });\n        case 'unknown':\n          return node;\n      }\n    }\n  }\n}\n\nfunction narrow(\n  node: Sanity.GroqCodegen.StructureNode,\n  condition: LogicExprNode,\n): Sanity.GroqCodegen.StructureNode {\n  switch (node.type) {\n    case 'Lazy': {\n      return createStructure({\n        type: 'Lazy',\n        get: () => narrow(node.get(), condition),\n        hashNamespace: 'Narrow',\n        hashInput: node.hash,\n      });\n    }\n\n    case 'Or': {\n      return narrowOr(node, condition);\n    }\n\n    case 'And': {\n      // TODO: should intersections combine object properties?\n      return createStructure({\n        ...node,\n        children: node.children.map((n) => narrow(n, condition)),\n      });\n    }\n\n    default: {\n      switch (accept(node, condition, new Set())) {\n        case 'yes':\n          return node;\n        case 'unknown':\n          // benefit of the doubt, leave the node in the structure\n          return node;\n        case 'no':\n          return createStructure({ type: 'Unknown' });\n      }\n    }\n  }\n}\n\nexport function narrowStructure(\n  node: Sanity.GroqCodegen.StructureNode,\n  condition: ExprNode,\n) {\n  return narrow(node, transformExprNodeToLogicExpr(condition));\n}\n","import { createStructure } from './create-structure';\n\nexport function reduceObjectStructures(\n  source: Sanity.GroqCodegen.StructureNode,\n  incoming: Sanity.GroqCodegen.StructureNode,\n  mode: 'replace' | 'union',\n): Sanity.GroqCodegen.StructureNode {\n  switch (source.type) {\n    default: {\n      throw new Error(\n        `Found unsupported source node type \"${source.type}\" in ` +\n          `reduceObjectStructures call. Please open an issue.`,\n      );\n    }\n\n    // TODO: for `And`s, should we combine the objects?\n    case 'And':\n    case 'Or': {\n      return createStructure({\n        ...source,\n        children: source.children.map((sourceChild) =>\n          reduceObjectStructures(sourceChild, incoming, mode),\n        ),\n      });\n    }\n    case 'Lazy': {\n      return createStructure({\n        type: 'Lazy',\n        hashNamespace: 'ReduceObjectStructuresSource',\n        hashInput: source.hash,\n        get: () => reduceObjectStructures(source.get(), incoming, mode),\n      });\n    }\n    case 'Object': {\n      switch (incoming.type) {\n        default: {\n          // TODO: show contextual warning. potentially throw and catch\n          // downstream for more context.\n          console.warn(\n            `Attempted to use ObjectSplat for unsupported type \"${incoming.type}\"`,\n          );\n          return createStructure({ type: 'Unknown' });\n        }\n        case 'And':\n        case 'Or': {\n          return createStructure({\n            ...incoming,\n            children: incoming.children.map((incomingChild) =>\n              reduceObjectStructures(source, incomingChild, mode),\n            ),\n          });\n        }\n        case 'Lazy': {\n          return createStructure({\n            type: 'Lazy',\n            hashNamespace: 'ReduceObjectStructuresIncoming',\n            hashInput: incoming.hash,\n            get: () => reduceObjectStructures(source, incoming.get(), mode),\n          });\n        }\n        case 'Object': {\n          type Property = Sanity.GroqCodegen.ObjectNode['properties'][number];\n\n          const resolvedProperties =\n            mode === 'replace'\n              ? Array.from(\n                  [...source.properties, ...incoming.properties]\n                    .reduce<Map<string, Property>>((map, property) => {\n                      map.set(property.key, property);\n                      return map;\n                    }, new Map())\n                    .values(),\n                )\n              : Array.from(\n                  [...source.properties, ...incoming.properties]\n                    .reduce<Map<string, Property>>((map, property) => {\n                      const existingProperty = map.get(property.key);\n\n                      if (existingProperty) {\n                        map.set(property.key, {\n                          key: property.key,\n                          value: createStructure({\n                            type: 'Or',\n                            children: [existingProperty.value, property.value],\n                          }),\n                        });\n                      } else {\n                        map.set(property.key, property);\n                      }\n                      return map;\n                    }, new Map())\n                    .values(),\n                );\n\n          return createStructure({\n            type: 'Object',\n            canBeNull: source.canBeNull || incoming.canBeNull,\n            canBeOptional: source.canBeOptional || incoming.canBeOptional,\n            properties: resolvedProperties,\n          });\n        }\n      }\n    }\n  }\n}\n","export class ResolveExpressionError extends Error {}\n","import chalk from 'chalk';\n\nexport const simpleLogger: Sanity.Codegen.Logger = {\n  debug: console.debug.bind(console),\n  error: (message) => console.error(`${chalk.red('✗')} ${message}`),\n  info: (message) => console.info(`${chalk.cyan('ⓘ')} ${message}`),\n  log: console.log.bind(console),\n  success: (message) => console.log(`${chalk.green('✓')} ${message}`),\n  verbose: (message) => {\n    if (process.env.CI !== 'true') {\n      console.log(message);\n    }\n  },\n  warn: (message) => console.warn(`${chalk.yellow('⚠️')} ${message}`),\n};\n","import { createStructure } from '../utils';\n\nexport const imageDimensionsStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: false,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imageDimensions',\n      }),\n    },\n    {\n      key: 'aspectRatio',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'height',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'width',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n  ],\n});\n\nexport const imagePaletteSwatchStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: false,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imagePaletteSwatch',\n      }),\n    },\n    {\n      key: 'background',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'foreground',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'population',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'title',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n  ],\n});\n\nexport const imagePaletteStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: false,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imagePalette',\n      }),\n    },\n    {\n      key: 'darkMuted',\n      value: imagePaletteSwatchStructure,\n    },\n    {\n      key: 'darkVibrant',\n      value: imagePaletteSwatchStructure,\n    },\n    {\n      key: 'dominant',\n      value: imagePaletteSwatchStructure,\n    },\n    {\n      key: 'lightMuted',\n      value: imagePaletteSwatchStructure,\n    },\n    {\n      key: 'lightVibrant',\n      value: imagePaletteSwatchStructure,\n    },\n    {\n      key: 'muted',\n      value: imagePaletteSwatchStructure,\n    },\n    {\n      key: 'vibrant',\n      value: imagePaletteSwatchStructure,\n    },\n  ],\n});\n\nexport const imageMetadataStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: false,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imageMetadata',\n      }),\n    },\n    {\n      key: 'dimensions',\n      value: imageDimensionsStructure,\n    },\n    {\n      key: 'hasAlpha',\n      value: createStructure({\n        type: 'Boolean',\n        canBeNull: false,\n        canBeOptional: false,\n      }),\n    },\n    {\n      key: 'isOpaque',\n      value: createStructure({\n        type: 'Boolean',\n        canBeNull: false,\n        canBeOptional: false,\n      }),\n    },\n    {\n      key: 'lqip',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'palette',\n      value: imagePaletteStructure,\n    },\n  ],\n});\n\nexport const imageAssetStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: false,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imageAsset',\n      }),\n    },\n    {\n      key: 'assetId',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'extension',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'metadata',\n      value: imageMetadataStructure,\n    },\n    {\n      key: 'mimeType',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'originalFilename',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'path',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'sha1hash',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'size',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'uploadId',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'url',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n  ],\n});\n\nexport const imageCropStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: true,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imageCrop',\n      }),\n    },\n    {\n      key: 'bottom',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'left',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'right',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'top',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n  ],\n});\n\nexport const imageHotspotStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: true,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'sanity.imageHotspot',\n      }),\n    },\n    {\n      key: 'height',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'width',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'x',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'y',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n  ],\n});\n","import {\n  imageAssetStructure,\n  imageDimensionsStructure,\n  imageMetadataStructure,\n  imagePaletteStructure,\n  imagePaletteSwatchStructure,\n  imageCropStructure,\n  imageHotspotStructure,\n} from './image';\n\nexport const defaultStructures = [\n  imageAssetStructure,\n  imageDimensionsStructure,\n  imageMetadataStructure,\n  imagePaletteStructure,\n  imagePaletteSwatchStructure,\n  imageCropStructure,\n  imageHotspotStructure,\n];\n\nexport {\n  imageAssetStructure,\n  imageDimensionsStructure,\n  imageMetadataStructure,\n  imagePaletteStructure,\n  imagePaletteSwatchStructure,\n  imageCropStructure,\n  imageHotspotStructure,\n};\n","import { createStructure } from '../utils';\n\nexport const geopointStructure = createStructure({\n  type: 'Object',\n  canBeNull: false,\n  canBeOptional: true,\n  properties: [\n    {\n      key: '_type',\n      value: createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: false,\n        value: 'geopoint',\n      }),\n    },\n    {\n      key: 'lat',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'lng',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n    {\n      key: 'alt',\n      value: createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: false,\n        value: null,\n      }),\n    },\n  ],\n});\n","import {\n  imageAssetStructure,\n  imageCropStructure,\n  imageHotspotStructure,\n} from './default-structures';\nimport { geopointStructure } from './default-structures/geopoint';\nimport { removeOptional, createStructure, objectHash } from './utils';\n\nexport interface TransformSchemaToStructureOptions {\n  /**\n   * An extracted and normalized schema result from the\n   * `@sanity-codegen/extractor` package.\n   */\n  normalizedSchema: Sanity.SchemaDef.Schema;\n}\n\n/**\n * Takes in a schema (see the `@sanity-codegen/extractor` package) and\n * returns a `StructureNode`\n */\nexport function transformSchemaToStructure({\n  normalizedSchema,\n}: TransformSchemaToStructureOptions): Sanity.GroqCodegen.StructureNode {\n  return createStructure({\n    type: 'Array',\n    of: createStructure({\n      type: 'Or',\n      children: normalizedSchema.documents\n        .map((node) =>\n          removeOptional(\n            transformSchemaNodeToStructure({ node, normalizedSchema }),\n          ),\n        )\n        // for consistent output\n        .sort((a, b) => a.hash.localeCompare(b.hash, 'en')),\n    }),\n    canBeNull: false,\n    canBeOptional: false,\n  });\n}\n\ninterface TransformSchemaNodeToStructureOptions {\n  /**\n   * the schema node (extracted from `@sanity-codegen/extractor`) that\n   * will be converted to a structure node\n   */\n  node: Sanity.SchemaDef.SchemaNode;\n  /**\n   * An extracted and normalized schema result from the\n   * `@sanity-codegen/extractor` package.\n   */\n  normalizedSchema: Sanity.SchemaDef.Schema;\n}\n\n/**\n * Takes in just one schema node and returns a `StructureNode`\n */\nexport function transformSchemaNodeToStructure({\n  node,\n  normalizedSchema,\n}: TransformSchemaNodeToStructureOptions): Sanity.GroqCodegen.StructureNode {\n  switch (node.type) {\n    case 'RegistryReference': {\n      const referencedType = [\n        ...normalizedSchema.documents,\n        ...normalizedSchema.registeredTypes,\n      ].find((n) => n.name === node.to);\n\n      // TODO: could show warning\n      if (!referencedType) return createStructure({ type: 'Unknown' });\n\n      return createStructure({\n        type: 'Lazy',\n        // Note that the hash inputs are a function of the resulting getter\n        // value. This is necessary to prevent weird caching behavior.\n        hashNamespace: 'TransformSchemaToStructure',\n        // need to include a schema hash for tests because schemas can have\n        // the same referencedType.name and cause unwanted collisions\n        hashInput: `${objectHash(normalizedSchema)}:${referencedType.name}`,\n        get: () =>\n          transformSchemaNodeToStructure({\n            node: referencedType,\n            normalizedSchema,\n          }),\n      });\n    }\n    case 'Array': {\n      return createStructure({\n        type: 'Array',\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n        of: createStructure({\n          type: 'Or',\n          children: node.of.map((node) =>\n            transformSchemaNodeToStructure({ node, normalizedSchema }),\n          ),\n        }),\n      });\n    }\n    case 'Block': {\n      return createStructure({\n        type: 'Object',\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n        properties: [\n          {\n            key: '_key',\n            value: createStructure({\n              type: 'String',\n              canBeNull: false,\n              canBeOptional: false,\n              value: null,\n            }),\n          },\n          {\n            key: '_type',\n            value: createStructure({\n              type: 'String',\n              canBeNull: false,\n              canBeOptional: false,\n              value: 'block',\n            }),\n          },\n          {\n            key: 'children',\n            value: createStructure({\n              type: 'Array',\n              canBeNull: false,\n              // TODO: can this be marked as false?\n              canBeOptional: false,\n              of: createStructure({\n                type: 'Or',\n                children: [\n                  // span\n                  createStructure({\n                    type: 'Object',\n                    canBeNull: false,\n                    canBeOptional: false,\n                    properties: [\n                      {\n                        key: '_key',\n                        value: createStructure({\n                          type: 'String',\n                          canBeOptional: false,\n                          canBeNull: false,\n                          value: null,\n                        }),\n                      },\n                      {\n                        key: '_type',\n                        value: createStructure({\n                          type: 'String',\n                          canBeNull: false,\n                          canBeOptional: false,\n                          value: 'span',\n                        }),\n                      },\n                      {\n                        key: 'marks',\n                        value: createStructure({\n                          type: 'Array',\n                          canBeNull: false,\n                          canBeOptional: true,\n                          of: createStructure({ type: 'Unknown' }),\n                        }),\n                      },\n                      {\n                        key: 'text',\n                        value: createStructure({\n                          type: 'String',\n                          canBeNull: false,\n                          canBeOptional: true,\n                          value: null,\n                        }),\n                      },\n                    ],\n                  }),\n                  // the rest\n                  ...(node.of || []).map((child) =>\n                    transformSchemaNodeToStructure({\n                      node: child,\n                      normalizedSchema,\n                    }),\n                  ),\n                ],\n              }),\n            }),\n          },\n          {\n            key: 'markDefs',\n            value: createStructure({\n              type: 'Array',\n              canBeNull: false,\n              // TODO: can this be marked as false?\n              canBeOptional: true,\n              // TODO:\n              of: createStructure({ type: 'Unknown' }),\n            }),\n          },\n          {\n            key: 'style',\n            value: createStructure({\n              type: 'String',\n              canBeNull: false,\n              // TODO: can this be marked as false?\n              canBeOptional: true,\n              value: null,\n            }),\n          },\n        ],\n      });\n    }\n    case 'Boolean': {\n      return createStructure({\n        type: 'Boolean',\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n      });\n    }\n    case 'Date':\n    case 'Datetime':\n    case 'String':\n    case 'Text':\n    case 'Url': {\n      return createStructure({\n        type: 'String',\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n        value: null,\n      });\n    }\n    case 'Object':\n    case 'Document':\n    case 'File':\n    case 'Image': {\n      type ObjectProperties = Extract<\n        Sanity.GroqCodegen.StructureNode,\n        { type: 'Object' }\n      >['properties'];\n\n      const properties: ObjectProperties = [];\n\n      if (node.type === 'Document') {\n        properties.push({\n          key: '_type',\n          value: createStructure({\n            type: 'String',\n            canBeNull: false,\n            canBeOptional: false,\n            value: node.name,\n          }),\n        });\n\n        properties.push({\n          key: '_id',\n          value: createStructure({\n            type: 'String',\n            canBeNull: false,\n            canBeOptional: false,\n            value: null,\n          }),\n        });\n      }\n\n      if (node.type === 'File') {\n        properties.push({\n          key: 'asset',\n          value: createStructure({\n            type: 'Reference',\n            canBeNull: false,\n            canBeOptional: false,\n            to: createStructure({ type: 'Unknown' }),\n          }),\n        });\n      }\n\n      if (node.type === 'Image') {\n        properties.push({\n          key: 'asset',\n          value: createStructure({\n            type: 'Reference',\n            canBeNull: false,\n            canBeOptional: false,\n            to: imageAssetStructure,\n          }),\n        });\n\n        properties.push({ key: 'crop', value: imageCropStructure });\n        properties.push({ key: 'hotspot', value: imageHotspotStructure });\n      }\n\n      const fieldProperties = node.fields?.map((field) => ({\n        key: field.name,\n        value: transformSchemaNodeToStructure({\n          node: field.definition,\n          normalizedSchema,\n        }),\n      }));\n\n      if (fieldProperties) {\n        for (const fieldProperty of fieldProperties) {\n          properties.push(fieldProperty);\n        }\n      }\n\n      return createStructure({\n        type: 'Object',\n        properties,\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n      });\n    }\n\n    case 'Geopoint': {\n      return createStructure({\n        ...(geopointStructure as Sanity.GroqCodegen.ObjectNode),\n        canBeOptional: !node.codegen.required,\n      });\n    }\n\n    case 'Number': {\n      return createStructure({\n        type: 'Number',\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n        value: null,\n      });\n    }\n\n    case 'Reference': {\n      return createStructure({\n        type: 'Reference',\n        to: createStructure({\n          type: 'Or',\n          children: node.to.map((node) =>\n            transformSchemaNodeToStructure({ node, normalizedSchema }),\n          ),\n        }),\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n      });\n    }\n\n    case 'Slug': {\n      return createStructure({\n        type: 'Object',\n        properties: [\n          {\n            key: '_type',\n            value: createStructure({\n              type: 'String',\n              canBeNull: false,\n              canBeOptional: false,\n              value: 'slug',\n            }),\n          },\n          {\n            key: 'current',\n            value: createStructure({\n              type: 'String',\n              canBeNull: false,\n              canBeOptional: !node.codegen.required,\n              value: null,\n            }),\n          },\n          {\n            key: 'source',\n            value: createStructure({\n              type: 'String',\n              canBeNull: false,\n              canBeOptional: true,\n              value: null,\n            }),\n          },\n        ],\n        canBeNull: false,\n        canBeOptional: !node.codegen.required,\n      });\n    }\n\n    default: {\n      throw new Error(\n        // `schemaDef.type` should be never because we exhausted the list of\n        // possible items\n        // @ts-expect-error\n        `Schema Definition Type \"${node.type}\" not implemented yet.`,\n      );\n    }\n  }\n}\n","import type { parse } from 'groq-js';\nimport {\n  addNull,\n  removeOptional,\n  addOptionalToProperties,\n  narrowStructure,\n  createStructure,\n  isStructureOptional,\n  isStructureNull,\n  isStructureArray,\n  isStructureBoolean,\n  isStructureNumber,\n  isStructureString,\n  accessAttributeInStructure,\n  unwrapArray,\n  wrapArray,\n  unwrapReferences,\n  reduceObjectStructures,\n  isStructureObject,\n} from './utils';\nimport { transformSchemaToStructure } from './transform-schema-to-structure';\n\ntype ExprNode = ReturnType<typeof parse>;\n\nexport interface TransformGroqToStructureOptions {\n  /**\n   * A GROQ AST node from `groq-js`'s `parse` method\n   */\n  node: ExprNode;\n  /**\n   * An extracted and normalized schema result from the\n   * `@sanity-codegen/extractor` package.\n   */\n  normalizedSchema: Sanity.SchemaDef.Schema;\n  /**\n   * An array of scopes. These scopes stack as the GROQ AST is traversed and new\n   * contexts are created. This should be an empty array to start with.\n   */\n  scopes: Sanity.GroqCodegen.StructureNode[];\n}\n\n/**\n * Used to transform a GROQ AST (e.g. `ExprNode`) into a `StructureNode`\n */\nexport function transformGroqToStructure({\n  node,\n  normalizedSchema,\n  scopes,\n}: TransformGroqToStructureOptions): Sanity.GroqCodegen.StructureNode {\n  const scope = scopes[scopes.length - 1] as\n    | Sanity.GroqCodegen.StructureNode\n    | undefined;\n\n  switch (node.type) {\n    case 'Everything': {\n      return transformSchemaToStructure({ normalizedSchema: normalizedSchema });\n    }\n\n    // TODO: are these actually the same?\n    case 'Map':\n    case 'FlatMap': {\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      const exprResult = transformGroqToStructure({\n        node: node.expr,\n        scopes: [...scopes, baseResult],\n        normalizedSchema,\n      });\n\n      return exprResult;\n    }\n\n    case 'Filter': {\n      // e.g. the return type from everything\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      if (!isStructureArray(baseResult)) {\n        // TODO: warn that filter was used on non-array base\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return wrapArray(narrowStructure(unwrapArray(baseResult), node.expr), {\n        canBeOptional: false,\n        canBeNull: isStructureNull(baseResult),\n      });\n    }\n\n    case 'This': {\n      // TODO: could warn here\n      return scope || createStructure({ type: 'Unknown' });\n    }\n\n    case 'Parent': {\n      // TODO: support parent `n` operator\n      const parentScope = scopes[scopes.length - 2];\n      // TODO: could warn here\n      return parentScope || createStructure({ type: 'Unknown' });\n    }\n\n    case 'Parameter': {\n      // Not very easy to know what the intended type of a parameter is so we\n      // convert it to `Unknown`. For some cases (such as filtering), this\n      // shouldn't have an impact on the resulting types\n      return createStructure({ type: 'Unknown' });\n    }\n\n    case 'AccessElement': {\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      if (baseResult.type === 'Unknown') {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return addNull(removeOptional(unwrapArray(baseResult)));\n    }\n\n    case 'Projection': {\n      // e.g. the result of a filter\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      const baseResultHadArray = isStructureArray(baseResult);\n\n      const exprResult = transformGroqToStructure({\n        node: node.expr,\n        scopes: [\n          ...scopes,\n          baseResultHadArray ? unwrapArray(baseResult) : baseResult,\n        ],\n        normalizedSchema,\n      });\n\n      return baseResultHadArray\n        ? wrapArray(exprResult, {\n            canBeNull: isStructureNull(baseResult),\n            canBeOptional: isStructureOptional(baseResult),\n          })\n        : exprResult;\n    }\n\n    case 'Object': {\n      if (!node.attributes.length) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      const emptyObject = createStructure({\n        type: 'Object',\n        canBeNull: false,\n        canBeOptional: false,\n        properties: [],\n      });\n\n      const combinedObject =\n        node.attributes.reduce<Sanity.GroqCodegen.StructureNode>(\n          (acc, attribute) => {\n            switch (attribute.type) {\n              case 'ObjectAttributeValue': {\n                const value = transformGroqToStructure({\n                  node: attribute.value,\n                  normalizedSchema,\n                  scopes,\n                });\n\n                const singlePropertyObject = createStructure({\n                  type: 'Object',\n                  canBeNull: false,\n                  canBeOptional: false,\n                  properties: [\n                    {\n                      key: attribute.name,\n                      value: isStructureOptional(value)\n                        ? addNull(removeOptional(value))\n                        : value,\n                    },\n                  ],\n                });\n\n                return reduceObjectStructures(\n                  acc,\n                  singlePropertyObject,\n                  'replace',\n                );\n              }\n              case 'ObjectSplat': {\n                const value = transformGroqToStructure({\n                  node: attribute.value,\n                  normalizedSchema,\n                  scopes,\n                });\n\n                return reduceObjectStructures(acc, value, 'replace');\n              }\n              case 'ObjectConditionalSplat': {\n                const value = transformGroqToStructure({\n                  node: attribute.value,\n                  scopes,\n                  normalizedSchema,\n                });\n\n                return reduceObjectStructures(\n                  acc,\n                  addOptionalToProperties(value),\n                  'union',\n                );\n              }\n              default: {\n                console.warn(\n                  // @ts-expect-error `attribute` should be of type never\n                  `Found unsupported object attribute type \"${attribute.type}\"`,\n                );\n                return createStructure({ type: 'Unknown' });\n              }\n            }\n          },\n          emptyObject,\n        );\n\n      return combinedObject;\n    }\n\n    case 'Select': {\n      const children = node.alternatives.map((alternative) =>\n        transformGroqToStructure({\n          node: alternative.value,\n          scopes,\n          normalizedSchema,\n        }),\n      );\n\n      if (node.fallback) {\n        children.push(\n          transformGroqToStructure({\n            node: node.fallback,\n            scopes,\n            normalizedSchema,\n          }),\n        );\n      }\n\n      return createStructure({ type: 'Or', children });\n    }\n\n    case 'Array': {\n      // if there is a splat in the array literal then…\n      if (node.elements.some((element) => element.isSplat)) {\n        return createStructure({\n          // …we can't map to tuple type\n          type: 'Array',\n          canBeNull: false,\n          canBeOptional: false,\n          of: createStructure({\n            type: 'Or',\n            children: node.elements.map((element) => {\n              if (element.isSplat) {\n                return unwrapArray(\n                  transformGroqToStructure({\n                    node: element.value,\n                    scopes,\n                    normalizedSchema,\n                  }),\n                );\n              }\n\n              return transformGroqToStructure({\n                node: element.value,\n                scopes,\n                normalizedSchema,\n              });\n            }),\n          }),\n        });\n      }\n\n      // if there are no splats found, we can list each type out as a tuple\n      // to allow for better DX with decomposition\n      return createStructure({\n        type: 'Tuple',\n        canBeNull: false,\n        canBeOptional: false,\n        elements: node.elements.map((element) =>\n          transformGroqToStructure({\n            node: element.value,\n            scopes,\n            normalizedSchema,\n          }),\n        ),\n      });\n    }\n\n    case 'AccessAttribute': {\n      if (node.base) {\n        const baseResult = transformGroqToStructure({\n          node: node.base,\n          scopes: scopes,\n          normalizedSchema,\n        });\n\n        const next = { ...node };\n        delete next.base;\n\n        return transformGroqToStructure({\n          node: next,\n          scopes: [...scopes, baseResult],\n          normalizedSchema,\n        });\n      }\n\n      if (!scope) return createStructure({ type: 'Unknown' });\n\n      return accessAttributeInStructure(scope, node.name);\n    }\n\n    case 'Deref': {\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      return unwrapReferences(baseResult);\n    }\n\n    case 'Slice':\n    case 'Group':\n    case 'ArrayCoerce':\n    case 'Asc':\n    case 'Desc': {\n      return transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n    }\n\n    case 'Value': {\n      switch (typeof node.value) {\n        case 'string': {\n          return createStructure({\n            type: 'String',\n            canBeNull: false,\n            canBeOptional: false,\n            value: node.value,\n          });\n        }\n        case 'number': {\n          return createStructure({\n            type: 'Number',\n            canBeNull: false,\n            canBeOptional: false,\n            value: node.value,\n          });\n        }\n        case 'boolean': {\n          return createStructure({\n            type: 'Boolean',\n            canBeNull: false,\n            canBeOptional: false,\n          });\n        }\n        default: {\n          return createStructure({ type: 'Unknown' });\n        }\n      }\n    }\n\n    case 'Or':\n    case 'And': {\n      const leftResult = transformGroqToStructure({\n        node: node.left,\n        normalizedSchema,\n        scopes,\n      });\n\n      const rightResult = transformGroqToStructure({\n        node: node.right,\n        normalizedSchema,\n        scopes,\n      });\n\n      // TODO: could warn in these cases\n      if (!isStructureBoolean(leftResult)) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      if (!isStructureBoolean(rightResult)) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return createStructure({\n        type: 'Boolean',\n        canBeNull: isStructureNull(leftResult) || isStructureNull(rightResult),\n        canBeOptional:\n          isStructureOptional(leftResult) || isStructureOptional(rightResult),\n      });\n    }\n\n    case 'Not': {\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      if (!isStructureBoolean(baseResult)) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return createStructure({\n        type: 'Boolean',\n        canBeNull: isStructureNull(baseResult),\n        canBeOptional: isStructureOptional(baseResult),\n      });\n    }\n\n    case 'Pos':\n    case 'Neg': {\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      if (!isStructureNumber(baseResult)) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return createStructure({\n        type: 'Number',\n        canBeNull: isStructureNull(baseResult),\n        canBeOptional: isStructureOptional(baseResult),\n        value: null,\n      });\n    }\n\n    case 'OpCall': {\n      const leftStructure = transformGroqToStructure({\n        node: node.left,\n        scopes,\n        normalizedSchema,\n      });\n      const rightStructure = transformGroqToStructure({\n        node: node.right,\n        scopes,\n        normalizedSchema,\n      });\n\n      const canBeNull =\n        isStructureNull(leftStructure) || isStructureNull(rightStructure);\n      const canBeOptional =\n        isStructureOptional(leftStructure) ||\n        isStructureOptional(rightStructure);\n\n      switch (node.op) {\n        case '*':\n        case '**':\n        case '-':\n        case '/':\n        case '%': {\n          if (\n            !isStructureNumber(leftStructure) ||\n            !isStructureNumber(rightStructure)\n          ) {\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'Number',\n            canBeNull,\n            canBeOptional,\n            value: null,\n          });\n        }\n        case '<=':\n        case '<':\n        case '>':\n        case '>=': {\n          if (\n            !isStructureNumber(leftStructure) ||\n            !isStructureNumber(rightStructure)\n          ) {\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'Boolean',\n            canBeNull:\n              isStructureNull(leftStructure) || isStructureNull(rightStructure),\n            canBeOptional:\n              isStructureOptional(leftStructure) ||\n              isStructureOptional(rightStructure),\n          });\n        }\n        case '!=':\n        case '==':\n        case 'in':\n        case 'match': {\n          return createStructure({\n            type: 'Boolean',\n            canBeNull:\n              isStructureNull(leftStructure) || isStructureNull(rightStructure),\n            canBeOptional:\n              isStructureOptional(leftStructure) ||\n              isStructureOptional(rightStructure),\n          });\n        }\n        case '+': {\n          if (\n            isStructureNumber(leftStructure) &&\n            isStructureNumber(rightStructure)\n          ) {\n            return createStructure({\n              type: 'Number',\n              canBeNull,\n              canBeOptional,\n              value: null,\n            });\n          }\n\n          if (\n            isStructureString(leftStructure) &&\n            isStructureString(rightStructure)\n          ) {\n            const leftStringStructure =\n              leftStructure as Sanity.GroqCodegen.StringNode;\n            const rightStringStructure =\n              rightStructure as Sanity.GroqCodegen.StringNode;\n\n            return createStructure({\n              type: 'String',\n              canBeNull,\n              canBeOptional,\n              value:\n                leftStringStructure.value === null\n                  ? null\n                  : rightStringStructure.value === null\n                  ? null\n                  : `${leftStringStructure.value}${rightStringStructure.value}`,\n            });\n          }\n\n          return createStructure({ type: 'Unknown' });\n        }\n        default: {\n          throw new Error(\n            `Found expected operator \"${node.op}\". Please open an issue.`,\n          );\n        }\n      }\n    }\n\n    case 'InRange': {\n      const baseResult = transformGroqToStructure({\n        node: node.base,\n        scopes,\n        normalizedSchema,\n      });\n\n      const leftResult = transformGroqToStructure({\n        node: node.left,\n        scopes,\n        normalizedSchema,\n      });\n\n      const rightResult = transformGroqToStructure({\n        node: node.right,\n        scopes,\n        normalizedSchema,\n      });\n\n      if (!isStructureNumber(baseResult)) {\n        return createStructure({ type: 'Unknown' });\n      }\n\n      return createStructure({\n        type: 'Boolean',\n        canBeNull:\n          isStructureNull(baseResult) ||\n          isStructureNull(leftResult) ||\n          isStructureNull(rightResult),\n        canBeOptional:\n          isStructureOptional(baseResult) ||\n          isStructureOptional(leftResult) ||\n          isStructureOptional(rightResult),\n      });\n    }\n\n    case 'FuncCall': {\n      switch (node.name) {\n        case 'coalesce': {\n          return createStructure({\n            type: 'Or',\n            children: node.args.map((arg) =>\n              transformGroqToStructure({\n                node: arg,\n                scopes,\n                normalizedSchema,\n              }),\n            ),\n          });\n        }\n\n        case 'count': {\n          if (node.args.length !== 1) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          const [base] = node.args;\n          const baseResult = transformGroqToStructure({\n            node: base,\n            scopes,\n            normalizedSchema,\n          });\n\n          if (!isStructureArray(baseResult)) {\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'Number',\n            canBeNull: isStructureNull(baseResult),\n            canBeOptional: false,\n            value: null,\n          });\n        }\n\n        case 'defined':\n        case 'references': {\n          if (node.args.length !== 1) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'Boolean',\n            canBeNull: false,\n            canBeOptional: false,\n          });\n        }\n\n        case 'identity': {\n          if (node.args.length) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          // https://www.sanity.io/docs/groq-functions#ba5eef75ed4a\n          return createStructure({\n            type: 'String',\n            canBeNull: false,\n            canBeOptional: false,\n            value: null,\n          });\n        }\n\n        case 'length': {\n          if (node.args.length !== 1) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          const [base] = node.args;\n          const baseResult = transformGroqToStructure({\n            node: base,\n            scopes,\n            normalizedSchema,\n          });\n\n          if (!isStructureArray(baseResult) && !isStructureString(baseResult)) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'Number',\n            canBeNull:\n              isStructureNull(baseResult) || isStructureOptional(baseResult),\n            canBeOptional: false,\n            value: null,\n          });\n        }\n\n        case 'lower':\n        case 'upper': {\n          if (node.args.length !== 1) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          const [base] = node.args;\n          const baseResult = transformGroqToStructure({\n            node: base,\n            scopes,\n            normalizedSchema,\n          });\n\n          if (!isStructureString(baseResult)) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'String',\n            canBeNull:\n              isStructureNull(baseResult) || isStructureOptional(baseResult),\n            canBeOptional: false,\n            value:\n              baseResult.type !== 'String'\n                ? null\n                : typeof baseResult.value !== 'string'\n                ? null\n                : node.name === 'upper'\n                ? baseResult.value.toUpperCase()\n                : baseResult.value.toLowerCase(),\n          });\n        }\n\n        case 'now': {\n          if (node.args.length) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'String',\n            canBeNull: false,\n            canBeOptional: false,\n            value: null,\n          });\n        }\n\n        case 'round': {\n          if (node.args.length <= 0 || node.args.length > 2) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          const [first, second] = node.args.map((n) =>\n            transformGroqToStructure({\n              node: n,\n              scopes,\n              normalizedSchema,\n            }),\n          );\n\n          if (!isStructureNumber(first) && !isStructureNumber(second)) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          return createStructure({\n            type: 'Number',\n            canBeNull: isStructureNull(first) || isStructureOptional(first),\n            canBeOptional: false,\n            value: null,\n          });\n        }\n\n        default: {\n          console.warn(\n            `Function \"${node.name}\" is not currently supported in the given context. Please open an issue.`,\n          );\n          return createStructure({ type: 'Unknown' });\n        }\n      }\n    }\n\n    case 'PipeFuncCall': {\n      switch (node.name) {\n        case 'order': {\n          const baseResult = transformGroqToStructure({\n            node: node.base,\n            scopes,\n            normalizedSchema,\n          });\n\n          return baseResult;\n        }\n        case 'score': {\n          const baseResult = transformGroqToStructure({\n            node: node.base,\n            scopes,\n            normalizedSchema,\n          });\n\n          const baseIsArray = isStructureArray(baseResult);\n\n          if (!baseIsArray) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          const arrayOf = unwrapArray(baseResult);\n          if (!isStructureObject(arrayOf)) {\n            // TODO: warn here\n            return createStructure({ type: 'Unknown' });\n          }\n\n          const objectWithUnderscoreScore = createStructure({\n            type: 'Object',\n            canBeNull: false,\n            canBeOptional: false,\n            properties: [\n              {\n                key: '_score',\n                value: createStructure({\n                  type: 'Number',\n                  canBeNull: false,\n                  canBeOptional: false,\n                  value: null,\n                }),\n              },\n            ],\n          });\n\n          return wrapArray(\n            reduceObjectStructures(\n              arrayOf,\n              objectWithUnderscoreScore,\n              'replace',\n            ),\n            {\n              canBeNull: isStructureNull(baseResult),\n              canBeOptional: isStructureOptional(baseResult),\n            },\n          );\n        }\n        default: {\n          console.warn(\n            `Pipped function \"${node.name}\" is not currently supported.`,\n          );\n          return createStructure({ type: 'Unknown' });\n        }\n      }\n    }\n\n    // TODO: implement these operators\n    case 'Context':\n    case 'Selector':\n    case 'Tuple': {\n      console.warn(`\"${node.type}\" not implemented yet.`);\n\n      return createStructure({ type: 'Unknown' });\n    }\n\n    default: {\n      // @ts-expect-error Should never happen because we support all nodes\n      console.warn(`\"${node.type}\" not implemented yet.`);\n\n      return createStructure({ type: 'Unknown' });\n    }\n  }\n}\n","import * as t from '@babel/types';\nimport { isStructureOptional, removeOptional } from './utils';\n\nexport interface TransformStructureToTsOptions {\n  /**\n   * The input `StructureNode` to be converted to a `TSType`\n   */\n  structure: Sanity.GroqCodegen.StructureNode;\n  substitutions: { [hash: string]: t.TSType };\n}\n\nconst tsTypeForCircularRefs = (node: Sanity.GroqCodegen.StructureNode) =>\n  t.tsTypeReference(\n    t.tsQualifiedName(\n      t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Ref')),\n      t.identifier(`Ref_${node.hash}`),\n    ),\n  );\n\n/**\n * Takes in a `StructureNode` and returns an object with the resulting main\n * the type, `query`, as well as any named references created (necessary when\n * the schema has self-reference). Those references are stored in an object\n * keyed by that node's hash.\n *\n * The resulting `TSType`s can be printed to source code via `@babel/generator`.\n *\n * @see `generateTypes` for a reference implementation\n */\nexport function transformStructureToTs({\n  structure,\n  substitutions,\n}: TransformStructureToTsOptions) {\n  const lazyNodes = findAllLazyNodes(structure);\n\n  const createAlias = (node: Sanity.GroqCodegen.StructureNode) => {\n    const next = (n: Sanity.GroqCodegen.StructureNode) => {\n      if (lazyNodes.has(n.hash)) return tsTypeForCircularRefs(n);\n      return transform({ node: n, next, substitutions });\n    };\n\n    // purposefully run the transform first before `next`\n    return transform({ node, next, substitutions });\n  };\n\n  const aliasTypes = new Map(\n    Array.from(lazyNodes.values()).map((lazyNode) => [\n      lazyNode.hash,\n      createAlias(lazyNode),\n    ]),\n  );\n\n  const next = (node: Sanity.GroqCodegen.StructureNode) => {\n    if (aliasTypes.has(node.hash)) return tsTypeForCircularRefs(node);\n    return transform({ node, next, substitutions });\n  };\n\n  return {\n    tsType: next(structure),\n    substitutions: Object.fromEntries(\n      Array.from(aliasTypes).map(([hash]) => [\n        hash,\n        t.tsTypeReference(\n          t.tsQualifiedName(\n            t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Ref')),\n            t.identifier(`Ref_${hash}`),\n          ),\n        ),\n      ]),\n    ),\n    declarations: Object.fromEntries(\n      Array.from(aliasTypes).map(([hash, tsType]) => [\n        hash,\n        t.tsModuleDeclaration(\n          t.identifier('Sanity'),\n          t.tsModuleDeclaration(\n            t.identifier('Ref'),\n            t.tsModuleBlock([\n              t.tsTypeAliasDeclaration(\n                t.identifier(`Ref_${hash}`),\n                undefined,\n                tsType,\n              ),\n            ]),\n          ),\n        ),\n      ]),\n    ),\n  };\n}\n\nfunction findAllLazyNodes(structure: Sanity.GroqCodegen.StructureNode) {\n  const lazyNodes = new Map<string, Sanity.GroqCodegen.StructureNode>();\n\n  function traverse(node: Sanity.GroqCodegen.StructureNode) {\n    switch (node.type) {\n      case 'Lazy': {\n        if (lazyNodes.has(node.hash)) return;\n\n        lazyNodes.set(node.hash, node);\n        traverse(node.get());\n        return;\n      }\n      case 'And':\n      case 'Or': {\n        for (const child of node.children) {\n          traverse(child);\n        }\n        return;\n      }\n\n      case 'Object': {\n        for (const property of node.properties) {\n          if (isStructureOptional(property.value)) {\n            // this alteration is due to how the transform function below works.\n            // if inside an object, a value is found to be optional, the\n            // transform removes the optional value and marks the current\n            // property as optional instead. this alteration in the tree needs\n            // to be accounted for when finding all the lazy nodes\n            traverse(removeOptional(property.value));\n            continue;\n          }\n\n          traverse(property.value);\n        }\n        return;\n      }\n      case 'Array': {\n        // same comment as above\n        if (isStructureOptional(node.of)) {\n          traverse(removeOptional(node.of));\n          return;\n        }\n\n        traverse(node.of);\n        return;\n      }\n      case 'Reference': {\n        traverse(node.to);\n        return;\n      }\n    }\n  }\n\n  traverse(structure);\n\n  return lazyNodes;\n}\n\ninterface TransformOptions {\n  node: Sanity.GroqCodegen.StructureNode;\n  next: (node: Sanity.GroqCodegen.StructureNode) => t.TSType;\n  substitutions: { [hash: string]: t.TSType };\n}\n\n/**\n * Internal transform function that takes in a `StructureNode` and a `next`\n * function and returns a `TSType`.\n *\n * The `next` function is used to intercept the traversal and return different\n * `TSType`s depending on the context\n */\nfunction transform({ next, node, substitutions }: TransformOptions): t.TSType {\n  if (substitutions[node.hash]) {\n    return substitutions[node.hash];\n  }\n\n  let tsType: t.TSType;\n\n  switch (node.type) {\n    case 'And': {\n      tsType = t.tsIntersectionType(\n        node.children\n          .sort((a, b) => a.hash.localeCompare(b.hash, 'en'))\n          .map(next),\n      );\n      break;\n    }\n    case 'Boolean': {\n      tsType = t.tsBooleanKeyword();\n      break;\n    }\n    case 'Number': {\n      tsType = t.tsNumberKeyword();\n      break;\n    }\n    case 'Object': {\n      tsType = t.tsTypeLiteral(\n        node.properties\n          .sort((a, b) => a.key.localeCompare(b.key, 'en'))\n          .map(({ key, value }) => {\n            const valueIsOptional = isStructureOptional(value);\n\n            const propertySignature = t.tsPropertySignature(\n              t.stringLiteral(key),\n              t.tsTypeAnnotation(\n                next(valueIsOptional ? removeOptional(value) : value),\n              ),\n            );\n\n            propertySignature.optional = valueIsOptional;\n\n            return propertySignature;\n          }),\n      );\n      break;\n    }\n    case 'Or': {\n      tsType = t.tsUnionType(\n        node.children\n          .sort((a, b) => a.hash.localeCompare(b.hash, 'en'))\n          .map(next),\n      );\n      break;\n    }\n    case 'String': {\n      tsType = node.value\n        ? t.tsLiteralType(t.stringLiteral(node.value))\n        : t.tsStringKeyword();\n      break;\n    }\n    case 'Unknown': {\n      tsType = t.tsUnknownKeyword();\n      break;\n    }\n    case 'Lazy': {\n      tsType = next(node.get());\n      break;\n    }\n    case 'Reference': {\n      tsType = t.tsTypeReference(\n        t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Reference')),\n        t.tsTypeParameterInstantiation([next(node.to)]),\n      );\n      break;\n    }\n    case 'Array': {\n      tsType = t.tsArrayType(\n        next(isStructureOptional(node.of) ? removeOptional(node.of) : node.of),\n      );\n      break;\n    }\n    case 'Tuple': {\n      tsType = t.tsTupleType(node.elements.map(next));\n      break;\n    }\n    default: {\n      // TODO: better comment\n      // @ts-expect-error\n      throw new Error(node.type);\n    }\n  }\n\n  if ('canBeNull' in node || 'canBeOptional' in node) {\n    const types: t.TSType[] = [tsType];\n    if (node.canBeNull) types.push(t.tsNullKeyword());\n    if (node.canBeOptional) types.push(t.tsUndefinedKeyword());\n    tsType = t.tsUnionType(types);\n  }\n\n  return tsType;\n}\n","export function defaultGenerateTypeName(sanityTypeName: string) {\n  const typeName = `${sanityTypeName\n    .substring(0, 1)\n    .toUpperCase()}${sanityTypeName\n    // If using snake_case, remove underscores and convert to uppercase the letter following them.\n    .replace(/(_[A-Z])/gi, (replace) => replace.substring(1).toUpperCase())\n    .replace(/(-[A-Z])/gi, (replace) => replace.substring(1).toUpperCase())\n    .replace(/(\\.[A-Z])/gi, (replace) => replace.substring(1).toUpperCase())\n    .substring(1)}`;\n\n  return typeName;\n}\n","import * as t from '@babel/types';\nimport { parse } from 'groq-js';\nimport { transformGroqToStructure } from './transform-groq-to-structure';\nimport { transformStructureToTs } from './transform-structure-to-ts';\nimport { defaultGenerateTypeName } from './default-generate-type-name';\nimport { simpleLogger } from './utils';\n\ninterface GenerateQueryTypesOptions {\n  normalizedSchema: Sanity.SchemaDef.Schema;\n  substitutions: { [hash: string]: t.TSType };\n  extractedQueries: Array<{ queryKey: string; query: string }>;\n  /**\n   * optionally override the default logger (e.g. to silence it, etc)\n   */\n  logger?: Sanity.Codegen.Logger;\n}\n\nexport function generateQueryTypes({\n  normalizedSchema,\n  extractedQueries,\n  ...options\n}: GenerateQueryTypesOptions) {\n  // TODO: allow customizing this?\n  const workspaceIdentifier = defaultGenerateTypeName(normalizedSchema.name);\n\n  const { logger = simpleLogger } = options;\n  const queries = extractedQueries\n    .map(({ queryKey, query }) => {\n      let structure;\n      try {\n        structure = transformGroqToStructure({\n          node: parse(query),\n          scopes: [],\n          normalizedSchema,\n        });\n      } catch (e) {\n        logger.error(`Failed to parse query \\`${queryKey}\\`. ${e}`);\n        return null;\n      }\n\n      const { tsType, declarations, substitutions } = transformStructureToTs({\n        structure,\n        substitutions: options.substitutions,\n      });\n\n      return {\n        structure,\n        queryKey,\n        declarations: {\n          ...declarations,\n          [structure.hash]: t.tsModuleDeclaration(\n            t.identifier('Sanity'),\n            t.tsModuleDeclaration(\n              t.identifier(workspaceIdentifier),\n              t.tsModuleDeclaration(\n                t.identifier('Query'),\n                t.tsModuleBlock([\n                  t.tsTypeAliasDeclaration(\n                    t.identifier(queryKey),\n                    undefined,\n                    tsType,\n                  ),\n                ]),\n              ),\n            ),\n          ),\n        },\n        substitutions: {\n          ...substitutions,\n          [structure.hash]: t.tsTypeReference(\n            t.tsQualifiedName(\n              t.tsQualifiedName(\n                t.tsQualifiedName(\n                  t.identifier('Sanity'),\n                  t.identifier(workspaceIdentifier),\n                ),\n                t.identifier('Query'),\n              ),\n              t.identifier(queryKey),\n            ),\n          ),\n        },\n      };\n    })\n    .filter(<T>(t: T): t is NonNullable<T> => !!t);\n\n  const substitutions = queries.reduce<{ [key: string]: t.TSType }>(\n    (acc, { queryKey, substitutions }) => {\n      for (const [hash, substitution] of Object.entries(substitutions)) {\n        if (!acc[hash]) {\n          acc[hash] = substitution;\n        } else {\n          acc[`${hash}_${queryKey}`] = t.tsTypeReference(\n            t.tsQualifiedName(\n              t.tsQualifiedName(\n                t.tsQualifiedName(\n                  t.identifier('Sanity'),\n                  t.identifier(workspaceIdentifier),\n                ),\n                t.identifier('Query'),\n              ),\n              t.identifier(queryKey),\n            ),\n          );\n        }\n      }\n\n      return acc;\n    },\n    {},\n  );\n\n  const declarations = queries.reduce<{ [key: string]: t.TSModuleDeclaration }>(\n    (acc, { declarations, queryKey, structure }) => {\n      for (const [hash, declaration] of Object.entries(declarations)) {\n        if (!acc[hash]) {\n          acc[hash] = declaration;\n        } else {\n          acc[`${hash}_${queryKey}`] = t.tsModuleDeclaration(\n            t.identifier('Sanity'),\n            t.tsModuleDeclaration(\n              t.identifier(workspaceIdentifier),\n              t.tsModuleDeclaration(\n                t.identifier('Query'),\n                t.tsModuleBlock([\n                  t.tsTypeAliasDeclaration(\n                    t.identifier(queryKey),\n                    undefined,\n                    substitutions[structure.hash],\n                  ),\n                ]),\n              ),\n            ),\n          );\n        }\n      }\n\n      return acc;\n    },\n    {},\n  );\n\n  const queryKeys = Object.fromEntries(\n    queries.map((i) => [i.queryKey, i.structure.hash]),\n  );\n\n  return {\n    declarations: {\n      ...declarations,\n      _ClientConfig: t.tsModuleDeclaration(\n        t.identifier('Sanity'),\n        t.tsModuleDeclaration(\n          t.identifier(workspaceIdentifier),\n          t.tsModuleDeclaration(\n            t.identifier('Client'),\n            t.tsModuleBlock([\n              t.tsTypeAliasDeclaration(\n                t.identifier('Config'),\n                undefined,\n                t.tsTypeLiteral(\n                  Object.entries(queryKeys).map(([queryKey, hash]) => {\n                    return t.tsPropertySignature(\n                      t.identifier(queryKey),\n                      t.tsTypeAnnotation(\n                        substitutions[`${hash}_${queryKey}`] ||\n                          substitutions[hash],\n                      ),\n                    );\n                  }),\n                ),\n              ),\n            ]),\n          ),\n        ),\n      ),\n    },\n    substitutions,\n  };\n}\n","import * as t from '@babel/types';\nimport { defaultGenerateTypeName } from './default-generate-type-name';\nimport { transformSchemaNodeToStructure } from './transform-schema-to-structure';\nimport { transformStructureToTs } from './transform-structure-to-ts';\n\ninterface GenerateSchemaTypesOptions {\n  normalizedSchema: Sanity.SchemaDef.Schema;\n}\n\nexport function generateSchemaTypes({\n  normalizedSchema,\n}: GenerateSchemaTypesOptions) {\n  // TODO: allow customizing this?\n  const workspaceIdentifier = defaultGenerateTypeName(normalizedSchema.name);\n\n  const topLevelSchemaNodes = [\n    ...normalizedSchema.documents,\n    ...normalizedSchema.registeredTypes,\n  ];\n\n  const topLevelTypes = topLevelSchemaNodes.map((node) => {\n    const structure = transformSchemaNodeToStructure({\n      node,\n      normalizedSchema,\n    });\n\n    // TODO: allow customizing this?\n    const identifier = defaultGenerateTypeName(node.name);\n\n    const { tsType, declarations, substitutions } = transformStructureToTs({\n      structure,\n      substitutions: {},\n    });\n\n    return {\n      structure,\n      declarations: {\n        ...declarations,\n        [structure.hash]: t.tsModuleDeclaration(\n          t.identifier('Sanity'),\n          t.tsModuleDeclaration(\n            t.identifier(workspaceIdentifier),\n            t.tsModuleDeclaration(\n              t.identifier('Schema'),\n              t.tsModuleBlock([\n                t.tsTypeAliasDeclaration(\n                  t.identifier(identifier),\n                  undefined,\n                  tsType,\n                ),\n              ]),\n            ),\n          ),\n        ),\n      },\n      substitutions: {\n        ...substitutions,\n        [structure.hash]: t.tsTypeReference(\n          t.tsQualifiedName(\n            t.tsQualifiedName(\n              t.tsQualifiedName(\n                t.identifier('Sanity'),\n                t.identifier(workspaceIdentifier),\n              ),\n              t.identifier('Schema'),\n            ),\n            t.identifier(identifier),\n          ),\n        ),\n      },\n    };\n  });\n\n  const substitutions = Object.fromEntries(\n    topLevelTypes.flatMap(({ substitutions }) => Object.entries(substitutions)),\n  );\n\n  const declarations = Object.fromEntries(\n    topLevelTypes.flatMap(({ declarations }) => Object.entries(declarations)),\n  );\n\n  return { declarations, substitutions };\n}\n","import { defaultGenerateTypeName } from './default-generate-type-name';\n\n// TODO: utilize this error more and re-hydrate it when it goes over IPC\nexport class SchemaParseError extends Error {}\n\nconst getFormattedName = (i: any): string => {\n  if (i.name) return i.name;\n  return `(${['anonymous', i.type].filter(Boolean).join(' ')})`;\n};\n\nconst isRecord = (t: unknown): t is Record<string, unknown> => {\n  if (typeof t !== 'object') return false;\n  if (!t) return false;\n  return true;\n};\n\nfunction getCommonProps(\n  i: any,\n  omitOriginalNode: boolean,\n): Sanity.SchemaDef.CommonNodeProps {\n  return {\n    codegen: {\n      required: !!i.codegen?.required,\n    },\n    description: i.description || null,\n    hidden: !!i.hidden,\n    name: i.name || null,\n    readOnly: !!i.readOnly,\n    title: i.title || (i.name ? transformCamelCase(i.name) : null),\n    hasValidation: !!i.validation,\n    ...(!omitOriginalNode && {\n      originalNode: i,\n    }),\n  };\n}\n\nconst typeMap: Record<string, Sanity.SchemaDef.SchemaNode['type'] | undefined> =\n  {\n    array: 'Array',\n    block: 'Block',\n    object: 'Object',\n    document: 'Document',\n    boolean: 'Boolean',\n    date: 'Date',\n    datetime: 'Datetime',\n    geopoint: 'Geopoint',\n    slug: 'Slug',\n    text: 'Text',\n    url: 'Url',\n    image: 'Image',\n    file: 'File',\n    number: 'Number',\n    string: 'String',\n    reference: 'Reference',\n  };\n\nfunction normalizeFields(\n  t: any,\n  parents: Array<string | number>,\n  omitOriginalNode: boolean,\n) {\n  const fields: any[] = t.fields || [];\n\n  if (!t?.fields?.length) {\n    throw new SchemaParseError(\n      `Expected type \\`${parents.join(\n        '.',\n      )}\\` to have property \\`fields\\` with at least one field.`,\n    );\n  }\n\n  return fields.map((f: any) => {\n    const pathname = parents.join('.');\n\n    if (typeof f.name !== 'string') {\n      throw new SchemaParseError(\n        `\\`${pathname}\\` had a field missing a \\`name\\` string.`,\n      );\n    }\n\n    if (typeof f.type !== 'string') {\n      throw new SchemaParseError(\n        `\\`${pathname}\\` has an invalid \\`type\\`. Expected a string but got \\`${\n          f.type === null ? 'null' : typeof f.type\n        }\\``,\n      );\n    }\n\n    const schemaFieldDef: Sanity.SchemaDef.FieldDef = {\n      name: f.name,\n      title: f.title || transformCamelCase(f.name),\n      description: f.description || '',\n      hidden: !!f.hidden,\n      readOnly: !!f.readOnly,\n      codegen: { required: !!f.codegen?.required },\n      hasValidation: !!f.validation,\n      definition: normalizeType(f, parents, omitOriginalNode),\n    };\n\n    return schemaFieldDef;\n  });\n}\n\nfunction normalizeType(\n  t: unknown,\n  parents: Array<string | number>,\n  omitOriginalNode: boolean,\n) {\n  const pathname = [...parents, getFormattedName(t)].join('.');\n\n  if (!isRecord(t)) {\n    throw new SchemaParseError(\n      `Expected \\`${pathname}\\` to be a non-null object.`,\n    );\n  }\n  if (typeof t.type !== 'string') {\n    throw new SchemaParseError(`Expected \\`${pathname}.type\\` to be a string.`);\n  }\n\n  const type = typeMap[t.type] || t.type;\n\n  switch (type) {\n    case 'Array': {\n      const of = t.of;\n\n      if (!of) {\n        throw new SchemaParseError(\n          `\\`${pathname}\\` was of type \\`array\\` but did not have an \\`of\\` property.`,\n        );\n      }\n\n      const schemaArrayDef: Sanity.SchemaDef.ArrayNode = {\n        ...getCommonProps(t, omitOriginalNode),\n        type,\n        of: Array.isArray(of)\n          ? of.map((i, index) =>\n              normalizeType(i, [...parents, index], omitOriginalNode),\n            )\n          : [normalizeType(of, [...parents, 0], omitOriginalNode)],\n        list: normalizeList(t, [...parents, getFormattedName(t)]),\n      };\n\n      return schemaArrayDef;\n    }\n\n    case 'Block': {\n      const of = t.of;\n\n      const schemaBlockDef: Sanity.SchemaDef.BlockNode = {\n        ...getCommonProps(t, omitOriginalNode),\n        type,\n        of: of\n          ? Array.isArray(of)\n            ? of.map((i, index) =>\n                normalizeType(i, [...parents, index], omitOriginalNode),\n              )\n            : [normalizeType(of, [...parents, 0], omitOriginalNode)]\n          : null,\n        // TODO: implement this\n        markDefs: [],\n      };\n\n      return schemaBlockDef;\n    }\n\n    case 'Object': {\n      const schemaDef: Sanity.SchemaDef.ObjectNode = {\n        ...getCommonProps(t, omitOriginalNode),\n        type,\n        fields: normalizeFields(\n          t,\n          [...parents, getFormattedName(t)],\n          omitOriginalNode,\n        ),\n      };\n\n      return schemaDef;\n    }\n\n    case 'Document': {\n      const { name, title, ...defProps } = getCommonProps(t, omitOriginalNode);\n\n      if (!name || typeof name !== 'string') {\n        throw new SchemaParseError(`\\`name\\` is required for documents`);\n      }\n\n      if (!title || typeof title !== 'string') {\n        throw new SchemaParseError(`\\`title\\` is required for documents`);\n      }\n\n      const schemaDef: Sanity.SchemaDef.DocumentNode = {\n        ...defProps,\n        name,\n        title,\n        type,\n        fields: normalizeFields(\n          t,\n          [...parents, getFormattedName(t)],\n          omitOriginalNode,\n        ),\n      };\n\n      return schemaDef;\n    }\n\n    case 'Boolean':\n    case 'Date':\n    case 'Datetime':\n    case 'Geopoint':\n    case 'Slug':\n    case 'Text':\n    case 'Url': {\n      const node: Extract<Sanity.SchemaDef.SchemaNode, { type: typeof type }> =\n        {\n          ...getCommonProps(t, omitOriginalNode),\n          type,\n        };\n      return node;\n    }\n\n    case 'Image':\n    case 'File': {\n      const node: Extract<Sanity.SchemaDef.SchemaNode, { type: typeof type }> =\n        {\n          ...getCommonProps(t, omitOriginalNode),\n          type,\n          fields: t.fields\n            ? normalizeFields(\n                t,\n                [...parents, getFormattedName(t)],\n                omitOriginalNode,\n              )\n            : null,\n        };\n\n      return node;\n    }\n\n    case 'Number':\n    case 'String': {\n      const node: Extract<Sanity.SchemaDef.SchemaNode, { type: typeof type }> =\n        {\n          ...getCommonProps(t, omitOriginalNode),\n          type,\n          list: normalizeList(t, [...parents, getFormattedName(t)]),\n        };\n\n      return node;\n    }\n\n    case 'Reference': {\n      // TODO: confirm references are to documents\n      const to = t.to;\n\n      if (!to) {\n        throw new SchemaParseError(\n          `\\`${pathname}\\` was of type \\`reference\\` but did not have an \\`to\\` property.`,\n        );\n      }\n\n      const node: Sanity.SchemaDef.ReferenceNode = {\n        ...getCommonProps(t, omitOriginalNode),\n        type,\n        to: (Array.isArray(to) ? to : [to]).map((i: any) => {\n          if (!i.type) {\n            throw new SchemaParseError(\n              `\\`${pathname}\\` of type \\`reference\\` has a \\`to\\` value without specifying a \\`type\\`.`,\n            );\n          }\n\n          const n: Sanity.SchemaDef.RegistryReferenceNode = {\n            ...getCommonProps(i, omitOriginalNode),\n            to: i.type,\n            type: 'RegistryReference',\n          };\n          return n;\n        }),\n        weak: !!t.weak,\n      };\n\n      return node;\n    }\n\n    // if not an intrinsic type, then assume it's a registry reference to\n    // another type.\n    //\n    // TODO: confirm this is not an unknown type by checking that a top-level\n    // reference does exist\n    default: {\n      const node: Sanity.SchemaDef.RegistryReferenceNode = {\n        ...getCommonProps(t, omitOriginalNode),\n        type: 'RegistryReference',\n        to: t.type,\n      };\n      return node;\n    }\n  }\n}\n\nconst transformCamelCase = (camelCase: string) => {\n  const normalizedCamelCase = defaultGenerateTypeName(camelCase);\n\n  return `${normalizedCamelCase\n    .substring(0, 1)\n    .toUpperCase()}${normalizedCamelCase\n    .substring(1)\n    .replace(/([A-Z])/g, ' $1')}`;\n};\n\nfunction normalizeList(\n  t: any,\n  parents: Array<string | number>,\n): Sanity.SchemaDef.ListOptionsDef<any> | null {\n  const list = t?.options?.list;\n\n  const pathname = parents.join('.');\n\n  if (!list) return null;\n  if (!Array.isArray(list)) {\n    throw new SchemaParseError(\n      `Expected \\`${pathname}.options.list\\` to be an array but found \\`${\n        list === null ? 'null' : typeof list\n      }\\` instead.`,\n    );\n  }\n\n  return list.map((option) => {\n    if (typeof option === 'string') {\n      return { title: transformCamelCase(option), value: option };\n    }\n\n    if (typeof option === 'number') {\n      return { title: option.toString(), value: option };\n    }\n\n    if (typeof option !== 'object') {\n      throw new SchemaParseError(\n        `Invalid \\`options.list\\` item for type \\`${pathname}\\`. Expected a string, number, or object but found \"${\n          option === null ? 'null' : typeof option\n        }\"`,\n      );\n    }\n\n    if (!('title' in option && 'value' in option)) {\n      throw new SchemaParseError(\n        `Invalid \\`options.list\\` item for type \\`${pathname}\\`. Expected item to have properties \\`title\\` and \\`value\\`.`,\n      );\n    }\n\n    return { title: option.title, value: option.value };\n  });\n}\n\nexport interface SchemaNormalizerOptions {\n  /**\n   * The name that will be forwarded to the resulting output type\n   */\n  name: string;\n  /**\n   * The raw sanity schema to be normalized\n   */\n  types: unknown[];\n  /**\n   * Whether or not to include the original node sanity in the output. This will\n   * make the `originalNode` property on a schema node be omitted. This is for\n   * serialization purposes.\n   */\n  omitOriginalNode?: boolean;\n}\n\n/**\n * Takes in a raw sanity schema and returns a statically typed normalized\n * version. This function also validates the raw schema, throwing when errors\n * are found.\n *\n * @param types raw sanity schema in the form of a type array\n * @returns normalized sanity schema\n */\n// TODO: refactor this API to take in a config object instead of a single argument\nexport function schemaNormalizer({\n  name,\n  types,\n  omitOriginalNode = false,\n}: SchemaNormalizerOptions): Sanity.SchemaDef.Schema {\n  if (!name) {\n    throw new SchemaParseError('No name was provided alongside a schema.');\n  }\n\n  const allRegisteredTypes = types.map((i) =>\n    normalizeType(i, [], omitOriginalNode),\n  );\n\n  // TODO: check if name is trying to override primitive types\n  for (const registeredType of allRegisteredTypes) {\n    if (!registeredType.name) {\n      throw new SchemaParseError(\n        'Found top-level registered type with no `name` field.',\n      );\n    }\n  }\n\n  const documents = allRegisteredTypes.filter(\n    (n): n is Sanity.SchemaDef.DocumentNode => n.type === 'Document',\n  );\n\n  const restOfRegisteredTypes = allRegisteredTypes.filter(\n    (n): n is Sanity.SchemaDef.RegisteredSchemaNode => n.type !== 'Document',\n  );\n\n  return {\n    name,\n    type: 'SchemaRoot',\n    documents,\n    registeredTypes: restOfRegisteredTypes,\n  };\n\n  // TODO: run validation afterwards\n}\n"],"names":["replacer","n","objectHashCache","WeakMap","objectHash","key","undefined","cached","get","result","hash","sanityCodegen","algorithm","encoding","replace","substring","padStart","set","unorderedHash","items","sanityCodegenUnordered","map","sort","a","b","localeCompare","memoize","transform","cache","Map","node","has","simplify","type","children","Array","from","reduce","child","nestedChild","values","length","ensureHash","_hash","rest","i","of","properties","value","elements","element","to","hashInput","hashNamespace","createStructure","createIsStructure","accept","mode","is","visitedNodes","got","Set","isStructure","structure","isStructureNumber","isStructureString","isStructureBoolean","isStructureArray","includes","isStructureNull","canBeNull","isStructureOptional","canBeOptional","isStructureObject","createTransform","namespace","transformLeaf","fn","addNull","addOptional","addOptionalToProperties","removeOptional","_unwrapArray","unwrapArray","unwrapReferences","unwrapLazy","wrapArray","options","accessAttributeInStructure","attributeName","matchingProperty","find","property","transformExprNodeToLogicExpr","groqNode","left","right","base","op","variableIdentifierNode","originalExprNode","valueNode","variable","name","literal","isSplat","withMemo","condition","results","foundUnknown","Error","narrowOr","filter","narrow","narrowStructure","reduceObjectStructures","source","incoming","sourceChild","console","warn","incomingChild","resolvedProperties","existingProperty","ResolveExpressionError","simpleLogger","debug","bind","error","message","chalk","red","info","cyan","log","success","green","verbose","process","env","CI","yellow","imageDimensionsStructure","imagePaletteSwatchStructure","imagePaletteStructure","imageMetadataStructure","imageAssetStructure","imageCropStructure","imageHotspotStructure","defaultStructures","geopointStructure","transformSchemaToStructure","normalizedSchema","documents","transformSchemaNodeToStructure","referencedType","registeredTypes","codegen","required","push","fieldProperties","fields","field","definition","fieldProperty","transformGroqToStructure","scopes","scope","baseResult","exprResult","expr","parentScope","baseResultHadArray","attributes","emptyObject","combinedObject","acc","attribute","singlePropertyObject","alternatives","alternative","fallback","some","next","leftResult","rightResult","leftStructure","rightStructure","leftStringStructure","rightStringStructure","args","arg","toUpperCase","toLowerCase","first","second","baseIsArray","arrayOf","objectWithUnderscoreScore","tsTypeForCircularRefs","t","tsTypeReference","tsQualifiedName","identifier","transformStructureToTs","substitutions","lazyNodes","findAllLazyNodes","createAlias","aliasTypes","lazyNode","tsType","Object","fromEntries","declarations","tsModuleDeclaration","tsModuleBlock","tsTypeAliasDeclaration","traverse","tsIntersectionType","tsBooleanKeyword","tsNumberKeyword","tsTypeLiteral","valueIsOptional","propertySignature","tsPropertySignature","stringLiteral","tsTypeAnnotation","optional","tsUnionType","tsLiteralType","tsStringKeyword","tsUnknownKeyword","tsTypeParameterInstantiation","tsArrayType","tsTupleType","types","tsNullKeyword","tsUndefinedKeyword","defaultGenerateTypeName","sanityTypeName","typeName","generateQueryTypes","extractedQueries","workspaceIdentifier","logger","queries","queryKey","query","parse","e","substitution","entries","declaration","queryKeys","_ClientConfig","generateSchemaTypes","topLevelSchemaNodes","topLevelTypes","flatMap","SchemaParseError","getFormattedName","Boolean","join","isRecord","getCommonProps","omitOriginalNode","description","hidden","readOnly","title","transformCamelCase","hasValidation","validation","originalNode","typeMap","array","block","object","document","boolean","date","datetime","geopoint","slug","text","url","image","file","number","string","reference","normalizeFields","parents","f","pathname","schemaFieldDef","normalizeType","schemaArrayDef","isArray","index","list","normalizeList","schemaBlockDef","markDefs","schemaDef","defProps","weak","camelCase","normalizedCamelCase","option","toString","schemaNormalizer","allRegisteredTypes","registeredType","restOfRegisteredTypes"],"mappings":"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"}