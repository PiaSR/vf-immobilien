"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pluckGroqFromFiles = pluckGroqFromFiles;
exports.pluckGroqFromSource = pluckGroqFromSource;
var _globby = _interopRequireDefault(require("globby"));
var _core = require("@babel/core");
var _babelMerge = _interopRequireDefault(require("babel-merge"));
var t = _interopRequireWildcard(require("@babel/types"));
var _pool = _interopRequireDefault(require("@ricokahler/pool"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _register = _interopRequireWildcard(require("@babel/register"));
var _utils = require("./utils");
var _resolveExpressionError = require("./resolve-expression-error");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// @ts-expect-error

const defaultPluckBabelOptions = {
  presets: [['@babel/preset-env', {
    targets: 'maintained node versions'
  }], '@babel/preset-typescript'],
  rootMode: 'upward-optional',
  extensions: ['.js', '.jsx', '.ts', '.tsx']
};
// TODO: update this link to main when published
/**
 * Given a source file as a string, this function will extract the queries and
 * their corresponding query keys.
 *
 * In order for a GROQ query to be plucked/extracted, the expression must match
 * the form:
 *
 * ```ts
 * anyCallExpression('QueryKey', groq`*[_type == 'foo']`)
 * ```
 *
 * The first argument of the call expression must be a string literal and the
 * second argument must be a tagged template literal expression with the tag
 * matching the one provided (default is `groq`). The 3rd argument
 * (i.e. query parameters) does not need to be present.
 *
 * For the second argument (the query), there is some limited support for
 * template literals with expressions in them.
 *
 * See [here][0] for more info.
 *
 * This function also accepts an babel options configuration object that is
 * merged with a provided default configuration.
 *
 * [0]: https://github.com/ricokahler/sanity-codegen/tree/alpha/packages/core#expressionsupport
 */
async function pluckGroqFromSource({
  source,
  filename,
  babelOptions: inputBabelOptions,
  resolvePluckedFile = require.resolve,
  groqTagName = 'groq',
  logger = _utils.simpleLogger
}) {
  const babelOptions = (0, _babelMerge.default)(defaultPluckBabelOptions, inputBabelOptions || {});
  (0, _register.default)(babelOptions);
  const babelOptionsWithoutExtensions = {
    ...babelOptions
  };
  // causes error "Error: Unknown option: .extensions."
  delete babelOptionsWithoutExtensions.extensions;
  function parseSourceFile(source, filename) {
    const result = (0, _core.parse)(source, {
      ...babelOptionsWithoutExtensions,
      filename
    });
    if (!result) {
      throw new _resolveExpressionError.ResolveExpressionError(`Failed to parse ${filename}`);
    }
    if (t.isProgram(result)) {
      throw new _resolveExpressionError.ResolveExpressionError(`Got type \`Program\` for ${filename} when type \`File\` was expected. Please open an issue.`);
    }
    return result;
  }
  try {
    const queriesToPluck = [];
    const tree = parseSourceFile(source, filename);
    (0, _core.traverse)(tree, {
      CallExpression({
        node,
        scope
      }) {
        const [queryKeyLiteral, groqTemplateExpression] = node.arguments;

        // a bunch of early returns to ensure the current expression matches
        // the shape of: sanity.query('QueryKey', groq`*`)
        if (!t.isStringLiteral(queryKeyLiteral)) return;
        if (!t.isTaggedTemplateExpression(groqTemplateExpression)) return;
        if (!t.isIdentifier(groqTemplateExpression.tag)) return;
        if (groqTemplateExpression.tag.name !== groqTagName) return;
        const queryKey = queryKeyLiteral.value;
        if (!/[A-Z][\w$]*/.test(queryKey)) {
          logger.warn(`Query Keys must be a valid TypeScript identifiers and must ` + `also start with a capital letter. Check query key ` + `\`${queryKey}\`.`);
          return;
        }
        queriesToPluck.push({
          queryKey,
          queryExpressionToResolve: groqTemplateExpression,
          queryScope: scope
        });
      }
    });
    const pluckedQueries = await (0, _pool.default)({
      collection: queriesToPluck,
      maxConcurrency: 5,
      task: async ({
        queryKey,
        queryExpressionToResolve,
        queryScope
      }) => ({
        queryKey,
        query: await (0, _utils.resolveExpression)({
          node: queryExpressionToResolve,
          file: tree,
          scope: queryScope,
          filename,
          parseSourceFile,
          resolvePluckedFile
        })
      })
    });
    return pluckedQueries;
  } finally {
    (0, _register.revert)();
  }
}
/**
 * Goes through each specified file and statically plucks groq queries and their
 * corresponding query keys. @see `pluckGroqFromSource` for more info.
 */
async function pluckGroqFromFiles({
  include,
  exclude,
  root = process.cwd(),
  babelOptions,
  logger = _utils.simpleLogger
}) {
  logger.verbose('Finding files to extract queries from…');
  const inclusions = typeof include === 'function' ? [] : Array.isArray(include) ? include : [include];
  const exclusions = Array.isArray(exclude) ? exclude : [exclude];
  const filenames = Array.from(new Set(typeof include === 'function' ? await include() : await (0, _globby.default)([...inclusions, ...exclusions.map(pattern => `!${pattern}`)], {
    cwd: root
  })));
  logger.info(`Found ${filenames.length} candidate file${filenames.length === 1 ? '' : 's'}`);
  let progress = 0;
  const extractedQueries = (await (0, _pool.default)({
    collection: filenames,
    maxConcurrency: 50,
    task: async filename => {
      progress += 1;
      logger.verbose(`Extracting queries… ${Math.round(progress * 100 / filenames.length)}% (${progress}/${filenames.length})`);
      const resolvedFilename = _path.default.resolve(root, filename);
      const buffer = await _fs.default.promises.readFile(resolvedFilename);
      const source = buffer.toString();
      return pluckGroqFromSource({
        source,
        filename: resolvedFilename,
        babelOptions,
        logger
      });
    }
  })).flat();
  logger[extractedQueries.length === 0 ? 'warn' : 'info'](`Found ${extractedQueries.length} ${extractedQueries.length === 1 ? 'query' : 'queries'} from ${filenames.length} files.`);
  const queryKeys = new Set();
  for (const {
    queryKey
  } of extractedQueries) {
    if (queryKeys.has(queryKey)) {
      throw new Error(`Saw query key \`${queryKey}\` more than once. Each query key must ` + `be unique`);
    }
    queryKeys.add(queryKey);
  }
  return extractedQueries;
}