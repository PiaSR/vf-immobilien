"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addOptionalToProperties = exports.addOptional = exports.addNull = void 0;
exports.createTransform = createTransform;
exports.unwrapReferences = exports.unwrapArray = exports.removeOptional = void 0;
var _createStructure = require("./create-structure");
var _isStructure = require("./is-structure");
function createTransform({
  namespace,
  accept = () => true,
  transform: transformLeaf
}) {
  function memoize(fn) {
    const cache = new Map();
    return node => {
      if (cache.has(node.hash)) return cache.get(node.hash);
      const result = fn(node);
      cache.set(node.hash, result);
      return result;
    };
  }
  const transform = memoize(node => {
    if (node.type === 'And' || node.type === 'Or') {
      return (0, _createStructure.createStructure)({
        ...node,
        children: node.children.map(transform)
      });
    }
    if (node.type === 'Lazy') {
      return (0, _createStructure.createStructure)({
        type: 'Lazy',
        get: () => transform(node.get()),
        hashNamespace: namespace,
        hashInput: node.hash
      });
    }
    if (accept(node)) return transformLeaf(node);
    return node;
  });
  return transform;
}
const addNull = createTransform({
  namespace: 'AddNull',
  accept: node => node.type !== 'Unknown',
  transform: node => (0, _createStructure.createStructure)({
    ...node,
    canBeNull: true
  })
});
exports.addNull = addNull;
const addOptional = createTransform({
  namespace: 'AddNull',
  accept: node => node.type !== 'Unknown',
  transform: node => (0, _createStructure.createStructure)({
    ...node,
    canBeOptional: true
  })
});
exports.addOptional = addOptional;
const addOptionalToProperties = createTransform({
  namespace: 'AddOptionalToProperties',
  accept: node => node.type === 'Object',
  transform: node => (0, _createStructure.createStructure)({
    type: 'Object',
    canBeNull: node.canBeNull,
    canBeOptional: node.canBeOptional,
    properties: node.properties.map(({
      key,
      value
    }) => ({
      key,
      value: addOptional(value)
    }))
  })
});
exports.addOptionalToProperties = addOptionalToProperties;
const removeOptional = createTransform({
  namespace: 'RemoveOptional',
  accept: node => node.type !== 'Unknown',
  transform: node => (0, _createStructure.createStructure)({
    ...node,
    canBeOptional: false
  })
});
exports.removeOptional = removeOptional;
const _unwrapArray = createTransform({
  namespace: 'UnwrapArray',
  accept: node => node.type === 'Array' || node.type === 'Tuple',
  transform: node => {
    switch (node.type) {
      case 'Array':
        {
          return node.of;
        }
      case 'Tuple':
        {
          return (0, _createStructure.createStructure)({
            type: 'Or',
            children: node.elements
          });
        }
    }
  }
});
const unwrapArray = node => {
  if (!(0, _isStructure.isStructureArray)(node)) return node;
  return _unwrapArray(node);
};
exports.unwrapArray = unwrapArray;
const unwrapReferences = createTransform({
  namespace: 'UnwrapReferences',
  accept: node => node.type === 'Reference',
  // this is a bit of a special case since the transform is
  // 1. find reference
  // 2. unwrap one level of lazy
  transform: node => unwrapLazy(node.to)
});
exports.unwrapReferences = unwrapReferences;
function unwrapLazy(n) {
  switch (n.type) {
    case 'Lazy':
      {
        return n.get();
      }
    case 'And':
    case 'Or':
      {
        return (0, _createStructure.createStructure)({
          ...n,
          children: n.children.map(unwrapLazy)
        });
      }
    default:
      {
        return n;
      }
  }
}