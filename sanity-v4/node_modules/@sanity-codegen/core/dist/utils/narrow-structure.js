"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accept = void 0;
exports.narrowStructure = narrowStructure;
exports.transformExprNodeToLogicExpr = transformExprNodeToLogicExpr;
var _createStructure = require("./create-structure");
var _hash = require("./hash");
/**
 * An internal function that takes in an GROQ ExprNode and returns a normalized
 * `LogicExprNode` node used to evaluate against a set of types described by a
 * `StructureNode`
 *
 * @see `accept`
 */
function transformExprNodeToLogicExpr(groqNode) {
  switch (groqNode.type) {
    case 'And':
    case 'Or':
      {
        const children = [transformExprNodeToLogicExpr(groqNode.left), transformExprNodeToLogicExpr(groqNode.right)];
        return {
          type: groqNode.type,
          children,
          hash: (0, _hash.objectHash)([groqNode.type, (0, _hash.unorderedHash)(children.map(i => i.hash))])
        };
      }
    case 'Group':
      {
        return transformExprNodeToLogicExpr(groqNode.base);
      }
    case 'Not':
      {
        const child = transformExprNodeToLogicExpr(groqNode.base);
        return {
          type: 'Not',
          child,
          hash: (0, _hash.objectHash)(['Not', child.hash])
        };
      }
    case 'OpCall':
      {
        switch (groqNode.op) {
          case '!=':
            {
              const child = transformExprNodeToLogicExpr({
                ...groqNode,
                op: '=='
              });
              return {
                type: 'Not',
                child,
                hash: (0, _hash.objectHash)(['Not', child.hash])
              };
            }
          case '==':
            {
              const variableIdentifierNode = [groqNode.left, groqNode.right].find(n => n.type === 'AccessAttribute');

              // TODO consider this case
              // e.g. `base._type == 'foo'`
              if (variableIdentifierNode?.base) {
                return {
                  type: 'UnknownExpression',
                  originalExprNode: groqNode,
                  hash: 'unknown'
                };
              }

              // e.g. the `'foo''` of `_type == 'foo'`
              const valueNode = [groqNode.left, groqNode.right].find(n => n.type === 'Value');
              if (variableIdentifierNode && valueNode && (typeof valueNode.value === 'string' || typeof valueNode.value === 'number')) {
                const result = {
                  variable: variableIdentifierNode.name,
                  literal: valueNode.value
                };
                return {
                  type: 'SingleVariableEquality',
                  ...result,
                  hash: (0, _hash.objectHash)(['SingleVariableEquality', result])
                };
              }
              return {
                type: 'UnknownExpression',
                originalExprNode: groqNode,
                hash: 'unknown'
              };
            }
          case 'in':
            {
              if (groqNode.right.type === 'Array') {
                const children = groqNode.right.elements.map(({
                  value,
                  isSplat
                }) => transformExprNodeToLogicExpr({
                  ...groqNode,
                  op: isSplat ? 'in' : '==',
                  right: value
                }));
                return {
                  type: 'Or',
                  children,
                  hash: (0, _hash.objectHash)(['Or', (0, _hash.unorderedHash)(children.map(i => i.hash))])
                };
              }
              return {
                type: 'UnknownExpression',
                originalExprNode: groqNode,
                hash: 'unknown'
              };
            }
          default:
            {
              return {
                type: 'UnknownExpression',
                originalExprNode: groqNode,
                hash: 'unknown'
              };
            }
        }
      }
    case 'Value':
      {
        if (groqNode.value === false) {
          return {
            type: 'Literal',
            hash: 'false',
            value: false
          };
        }
        if (groqNode.value === true) {
          return {
            type: 'Literal',
            hash: 'true',
            value: true
          };
        }
        return {
          type: 'UnknownExpression',
          originalExprNode: groqNode,
          hash: 'unknown'
        };
      }
    default:
      {
        return {
          type: 'UnknownExpression',
          originalExprNode: groqNode,
          hash: 'unknown'
        };
      }
  }
}
const withMemo = fn => {
  const cache = new Map();
  return (node, condition, visitedNodes) => {
    const key = `${node.hash}__${condition.hash}`;
    if (cache.has(key)) return cache.get(key);
    const result = fn(node, condition, visitedNodes);
    cache.set(key, result);
    return result;
  };
};
const accept = withMemo((structure, condition, visitedNodes) => {
  switch (condition.type) {
    case 'And':
      {
        const results = condition.children.map(child => accept(structure, child, visitedNodes));
        let foundUnknown = false;
        for (const result of results) {
          if (result === 'no') return 'no';
          if (result === 'unknown') foundUnknown = true;
        }
        if (foundUnknown) return 'unknown';
        return 'yes';
      }
    case 'Or':
      {
        const results = condition.children.map(child => accept(structure, child, visitedNodes));
        let foundUnknown = false;
        for (const result of results) {
          if (result === 'yes') return 'yes';
          if (result === 'unknown') foundUnknown = true;
        }
        if (foundUnknown) return 'unknown';
        return 'no';
      }
    case 'Not':
      {
        const result = accept(structure, condition.child, visitedNodes);
        if (result === 'yes') return 'no';
        if (result === 'no') return 'yes';
        return 'unknown';
      }
    case 'Literal':
      {
        return condition.value ? 'yes' : 'no';
      }
    case 'SingleVariableEquality':
      {
        switch (structure.type) {
          case 'Lazy':
            {
              const got = structure.get();
              if (visitedNodes.has(got.hash)) return 'no';
              return accept(got, condition, new Set([...visitedNodes, got.hash]));
            }
          case 'And':
            {
              const results = structure.children.map(child => accept(child, condition, visitedNodes));
              for (const result of results) {
                if (result === 'unknown') return 'unknown';
                if (result === 'no') return 'no';
              }
              return 'yes';
            }
          case 'Or':
            {
              const results = structure.children.map(child => accept(child, condition, visitedNodes));
              for (const result of results) {
                if (result === 'unknown') return 'unknown';
                if (result === 'yes') return 'yes';
              }
              return 'no';
            }
          case 'Boolean':
          case 'Number':
          case 'String':
          case 'Tuple':
          case 'Array':
            {
              return 'no';
            }
          case 'Reference':
            {
              // TODO: this could be updated to fallback to an object structure
              // with {_type: 'reference', _ref: string}
              return 'no';
            }
          case 'Object':
            {
              const matchingProperty = structure.properties.find(property => property.key === condition.variable);
              if (!matchingProperty) return 'unknown';
              if ('value' in matchingProperty.value && matchingProperty.value.value === condition.literal) {
                return 'yes';
              }
              return 'no';
            }
          case 'Unknown':
            {
              return 'unknown';
            }
          default:
            {
              // @ts-expect-error
              throw new Error(`${structure.type} not implemented yet`);
            }
        }
      }
    case 'UnknownExpression':
      {
        return 'unknown';
      }
    default:
      {
        // @ts-expect-error
        throw new Error(`${condition.type} not implemented yet`);
      }
  }
});
exports.accept = accept;
function narrowOr(node, condition) {
  switch (node.type) {
    case 'Or':
      {
        const result = node.children.filter(child => accept(child, condition, new Set()) !== 'no').map(child => narrowOr(child, condition));
        if (!result.length) {
          return (0, _createStructure.createStructure)({
            type: 'Unknown'
          });
        }
        return (0, _createStructure.createStructure)({
          type: 'Or',
          children: result
        });
      }
    case 'Lazy':
      {
        return (0, _createStructure.createStructure)({
          type: 'Lazy',
          get: () => narrowOr(node.get(), condition),
          hashNamespace: 'NarrowOr',
          hashInput: node.hash
        });
      }
    default:
      {
        switch (accept(node, condition, new Set())) {
          case 'yes':
            return node;
          case 'no':
            return (0, _createStructure.createStructure)({
              type: 'Unknown'
            });
          case 'unknown':
            return node;
        }
      }
  }
}
function narrow(node, condition) {
  switch (node.type) {
    case 'Lazy':
      {
        return (0, _createStructure.createStructure)({
          type: 'Lazy',
          get: () => narrow(node.get(), condition),
          hashNamespace: 'Narrow',
          hashInput: node.hash
        });
      }
    case 'Or':
      {
        return narrowOr(node, condition);
      }
    case 'And':
      {
        // TODO: should intersections combine object properties?
        return (0, _createStructure.createStructure)({
          ...node,
          children: node.children.map(n => narrow(n, condition))
        });
      }
    default:
      {
        switch (accept(node, condition, new Set())) {
          case 'yes':
            return node;
          case 'unknown':
            // benefit of the doubt, leave the node in the structure
            return node;
          case 'no':
            return (0, _createStructure.createStructure)({
              type: 'Unknown'
            });
        }
      }
  }
}
function narrowStructure(node, condition) {
  return narrow(node, transformExprNodeToLogicExpr(condition));
}