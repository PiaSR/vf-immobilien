/// <reference types="@sanity-codegen/types/core" />
type LazyNodeWithoutHash = Omit<Sanity.GroqCodegen.LazyNode, 'hash'> & {
    hashNamespace: string;
    hashInput: string;
};
type StructureNodeTypes = Exclude<Sanity.GroqCodegen.StructureNode['type'], 'Lazy'>;
type StructureNodeWithoutHash = {
    [P in StructureNodeTypes]: Omit<Extract<Sanity.GroqCodegen.StructureNode, {
        type: P;
    }>, 'hash'>;
}[StructureNodeTypes];
type InputNode = (StructureNodeWithoutHash | LazyNodeWithoutHash) & {
    hash?: string;
};
type Transform = (node: Sanity.GroqCodegen.StructureNode) => Sanity.GroqCodegen.StructureNode;
export declare const simplify: Transform;
/**
 * Adds hashes to new `StructureNode`s by looking at the current node's
 * properties. If the node has children (e.g. `And`s/`Or`s), then the hash will
 * use the direct children's hash as an input (this makes all hash computation
 * shallow).
 *
 * The result of this is then ran through `simplify` function memoized by the
 * node's resulting hash.
 *
 * Note: the `LazyNode` is a special case because it's not possible to derive a
 * hash automatically without pulling the lazy value so a `hashNamespace` and
 * a `hashInput` are required.
 */
export declare const createStructure: (node: InputNode) => Sanity.GroqCodegen.StructureNode;
export {};
//# sourceMappingURL=create-structure.d.ts.map