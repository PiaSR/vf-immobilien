"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.simplify = exports.createStructure = void 0;
var _hash2 = require("./hash");
const memoize = transform => {
  const cache = new Map();
  return node => {
    if (cache.has(node.hash)) return cache.get(node.hash);
    const result = transform(node);
    cache.set(node.hash, result);
    return result;
  };
};
const simplify = memoize(node => {
  if (node.type !== 'And' && node.type !== 'Or') return node;
  const children = Array.from(node.children.map(simplify).reduce((map, child) => {
    if (child.type === node.type) {
      for (const nestedChild of child.children) {
        map.set(nestedChild.hash, nestedChild);
      }
    } else {
      map.set(child.hash, child);
    }
    return map;
  }, new Map()).values()).sort((a, b) => a.hash.localeCompare(b.hash, 'en'));
  if (children.length === 0) return ensureHash({
    type: 'Unknown'
  });
  if (children.length === 1) return children[0];
  return ensureHash({
    ...node,
    children
  });
});
exports.simplify = simplify;
function ensureHash({
  // remove an pre-existing hash
  hash: _hash,
  ...node
}) {
  switch (node.type) {
    case 'And':
    case 'Or':
      {
        const {
          children,
          ...rest
        } = node;
        return {
          ...node,
          hash: (0, _hash2.objectHash)([rest, (0, _hash2.unorderedHash)(children.map(i => i.hash))])
        };
      }
    case 'Array':
      {
        const {
          of,
          ...rest
        } = node;
        return {
          ...node,
          hash: (0, _hash2.objectHash)([rest, of.hash])
        };
      }
    case 'Object':
      {
        const {
          properties,
          ...rest
        } = node;
        return {
          ...node,
          hash: (0, _hash2.objectHash)([rest, (0, _hash2.unorderedHash)(properties.map(i => [i.key, i.value.hash]))])
        };
      }
    case 'Tuple':
      {
        const {
          elements,
          ...rest
        } = node;
        return {
          ...node,
          hash: (0, _hash2.objectHash)([rest, elements.map(element => element.hash)])
        };
      }
    case 'Reference':
      {
        const {
          to,
          ...rest
        } = node;
        return {
          ...node,
          hash: (0, _hash2.objectHash)([rest, to.hash])
        };
      }
    case 'Unknown':
      {
        return {
          type: 'Unknown',
          hash: 'unknown'
        };
      }
    case 'Lazy':
      {
        const {
          hashInput,
          hashNamespace,
          ...rest
        } = node;
        return {
          // this is `rest` on purpose
          ...rest,
          hash: (0, _hash2.objectHash)(['Lazy', hashNamespace, hashInput])
        };
      }
    default:
      {
        return {
          ...node,
          hash: (0, _hash2.objectHash)(node)
        };
      }
  }
}

/**
 * Adds hashes to new `StructureNode`s by looking at the current node's
 * properties. If the node has children (e.g. `And`s/`Or`s), then the hash will
 * use the direct children's hash as an input (this makes all hash computation
 * shallow).
 *
 * The result of this is then ran through `simplify` function memoized by the
 * node's resulting hash.
 *
 * Note: the `LazyNode` is a special case because it's not possible to derive a
 * hash automatically without pulling the lazy value so a `hashNamespace` and
 * a `hashInput` are required.
 */
const createStructure = node => simplify(ensureHash(node));
exports.createStructure = createStructure;