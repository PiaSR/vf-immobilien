"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reduceObjectStructures = reduceObjectStructures;
var _createStructure = require("./create-structure");
function reduceObjectStructures(source, incoming, mode) {
  switch (source.type) {
    default:
      {
        throw new Error(`Found unsupported source node type "${source.type}" in ` + `reduceObjectStructures call. Please open an issue.`);
      }

    // TODO: for `And`s, should we combine the objects?
    case 'And':
    case 'Or':
      {
        return (0, _createStructure.createStructure)({
          ...source,
          children: source.children.map(sourceChild => reduceObjectStructures(sourceChild, incoming, mode))
        });
      }
    case 'Lazy':
      {
        return (0, _createStructure.createStructure)({
          type: 'Lazy',
          hashNamespace: 'ReduceObjectStructuresSource',
          hashInput: source.hash,
          get: () => reduceObjectStructures(source.get(), incoming, mode)
        });
      }
    case 'Object':
      {
        switch (incoming.type) {
          default:
            {
              // TODO: show contextual warning. potentially throw and catch
              // downstream for more context.
              console.warn(`Attempted to use ObjectSplat for unsupported type "${incoming.type}"`);
              return (0, _createStructure.createStructure)({
                type: 'Unknown'
              });
            }
          case 'And':
          case 'Or':
            {
              return (0, _createStructure.createStructure)({
                ...incoming,
                children: incoming.children.map(incomingChild => reduceObjectStructures(source, incomingChild, mode))
              });
            }
          case 'Lazy':
            {
              return (0, _createStructure.createStructure)({
                type: 'Lazy',
                hashNamespace: 'ReduceObjectStructuresIncoming',
                hashInput: incoming.hash,
                get: () => reduceObjectStructures(source, incoming.get(), mode)
              });
            }
          case 'Object':
            {
              const resolvedProperties = mode === 'replace' ? Array.from([...source.properties, ...incoming.properties].reduce((map, property) => {
                map.set(property.key, property);
                return map;
              }, new Map()).values()) : Array.from([...source.properties, ...incoming.properties].reduce((map, property) => {
                const existingProperty = map.get(property.key);
                if (existingProperty) {
                  map.set(property.key, {
                    key: property.key,
                    value: (0, _createStructure.createStructure)({
                      type: 'Or',
                      children: [existingProperty.value, property.value]
                    })
                  });
                } else {
                  map.set(property.key, property);
                }
                return map;
              }, new Map()).values());
              return (0, _createStructure.createStructure)({
                type: 'Object',
                canBeNull: source.canBeNull || incoming.canBeNull,
                canBeOptional: source.canBeOptional || incoming.canBeOptional,
                properties: resolvedProperties
              });
            }
        }
      }
  }
}