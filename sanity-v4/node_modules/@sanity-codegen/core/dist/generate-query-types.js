"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateQueryTypes = generateQueryTypes;
var t = _interopRequireWildcard(require("@babel/types"));
var _groqJs = require("groq-js");
var _transformGroqToStructure = require("./transform-groq-to-structure");
var _transformStructureToTs = require("./transform-structure-to-ts");
var _defaultGenerateTypeName = require("./default-generate-type-name");
var _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function generateQueryTypes({
  normalizedSchema,
  extractedQueries,
  ...options
}) {
  // TODO: allow customizing this?
  const workspaceIdentifier = (0, _defaultGenerateTypeName.defaultGenerateTypeName)(normalizedSchema.name);
  const {
    logger = _utils.simpleLogger
  } = options;
  const queries = extractedQueries.map(({
    queryKey,
    query
  }) => {
    let structure;
    try {
      structure = (0, _transformGroqToStructure.transformGroqToStructure)({
        node: (0, _groqJs.parse)(query),
        scopes: [],
        normalizedSchema
      });
    } catch (e) {
      logger.error(`Failed to parse query \`${queryKey}\`. ${e}`);
      return null;
    }
    const {
      tsType,
      declarations,
      substitutions
    } = (0, _transformStructureToTs.transformStructureToTs)({
      structure,
      substitutions: options.substitutions
    });
    return {
      structure,
      queryKey,
      declarations: {
        ...declarations,
        [structure.hash]: t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Query'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(queryKey), undefined, tsType)]))))
      },
      substitutions: {
        ...substitutions,
        [structure.hash]: t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier(workspaceIdentifier)), t.identifier('Query')), t.identifier(queryKey)))
      }
    };
  }).filter(t => !!t);
  const substitutions = queries.reduce((acc, {
    queryKey,
    substitutions
  }) => {
    for (const [hash, substitution] of Object.entries(substitutions)) {
      if (!acc[hash]) {
        acc[hash] = substitution;
      } else {
        acc[`${hash}_${queryKey}`] = t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier(workspaceIdentifier)), t.identifier('Query')), t.identifier(queryKey)));
      }
    }
    return acc;
  }, {});
  const declarations = queries.reduce((acc, {
    declarations,
    queryKey,
    structure
  }) => {
    for (const [hash, declaration] of Object.entries(declarations)) {
      if (!acc[hash]) {
        acc[hash] = declaration;
      } else {
        acc[`${hash}_${queryKey}`] = t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Query'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(queryKey), undefined, substitutions[structure.hash])]))));
      }
    }
    return acc;
  }, {});
  const queryKeys = Object.fromEntries(queries.map(i => [i.queryKey, i.structure.hash]));
  return {
    declarations: {
      ...declarations,
      _ClientConfig: t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier(workspaceIdentifier), t.tsModuleDeclaration(t.identifier('Client'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier('Config'), undefined, t.tsTypeLiteral(Object.entries(queryKeys).map(([queryKey, hash]) => {
        return t.tsPropertySignature(t.identifier(queryKey), t.tsTypeAnnotation(substitutions[`${hash}_${queryKey}`] || substitutions[hash]));
      })))]))))
    },
    substitutions
  };
}