"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformStructureToTs = transformStructureToTs;
var t = _interopRequireWildcard(require("@babel/types"));
var _utils = require("./utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const tsTypeForCircularRefs = node => t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Ref')), t.identifier(`Ref_${node.hash}`)));

/**
 * Takes in a `StructureNode` and returns an object with the resulting main
 * the type, `query`, as well as any named references created (necessary when
 * the schema has self-reference). Those references are stored in an object
 * keyed by that node's hash.
 *
 * The resulting `TSType`s can be printed to source code via `@babel/generator`.
 *
 * @see `generateTypes` for a reference implementation
 */
function transformStructureToTs({
  structure,
  substitutions
}) {
  const lazyNodes = findAllLazyNodes(structure);
  const createAlias = node => {
    const next = n => {
      if (lazyNodes.has(n.hash)) return tsTypeForCircularRefs(n);
      return transform({
        node: n,
        next,
        substitutions
      });
    };

    // purposefully run the transform first before `next`
    return transform({
      node,
      next,
      substitutions
    });
  };
  const aliasTypes = new Map(Array.from(lazyNodes.values()).map(lazyNode => [lazyNode.hash, createAlias(lazyNode)]));
  const next = node => {
    if (aliasTypes.has(node.hash)) return tsTypeForCircularRefs(node);
    return transform({
      node,
      next,
      substitutions
    });
  };
  return {
    tsType: next(structure),
    substitutions: Object.fromEntries(Array.from(aliasTypes).map(([hash]) => [hash, t.tsTypeReference(t.tsQualifiedName(t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Ref')), t.identifier(`Ref_${hash}`)))])),
    declarations: Object.fromEntries(Array.from(aliasTypes).map(([hash, tsType]) => [hash, t.tsModuleDeclaration(t.identifier('Sanity'), t.tsModuleDeclaration(t.identifier('Ref'), t.tsModuleBlock([t.tsTypeAliasDeclaration(t.identifier(`Ref_${hash}`), undefined, tsType)])))]))
  };
}
function findAllLazyNodes(structure) {
  const lazyNodes = new Map();
  function traverse(node) {
    switch (node.type) {
      case 'Lazy':
        {
          if (lazyNodes.has(node.hash)) return;
          lazyNodes.set(node.hash, node);
          traverse(node.get());
          return;
        }
      case 'And':
      case 'Or':
        {
          for (const child of node.children) {
            traverse(child);
          }
          return;
        }
      case 'Object':
        {
          for (const property of node.properties) {
            if ((0, _utils.isStructureOptional)(property.value)) {
              // this alteration is due to how the transform function below works.
              // if inside an object, a value is found to be optional, the
              // transform removes the optional value and marks the current
              // property as optional instead. this alteration in the tree needs
              // to be accounted for when finding all the lazy nodes
              traverse((0, _utils.removeOptional)(property.value));
              continue;
            }
            traverse(property.value);
          }
          return;
        }
      case 'Array':
        {
          // same comment as above
          if ((0, _utils.isStructureOptional)(node.of)) {
            traverse((0, _utils.removeOptional)(node.of));
            return;
          }
          traverse(node.of);
          return;
        }
      case 'Reference':
        {
          traverse(node.to);
          return;
        }
    }
  }
  traverse(structure);
  return lazyNodes;
}
/**
 * Internal transform function that takes in a `StructureNode` and a `next`
 * function and returns a `TSType`.
 *
 * The `next` function is used to intercept the traversal and return different
 * `TSType`s depending on the context
 */
function transform({
  next,
  node,
  substitutions
}) {
  if (substitutions[node.hash]) {
    return substitutions[node.hash];
  }
  let tsType;
  switch (node.type) {
    case 'And':
      {
        tsType = t.tsIntersectionType(node.children.sort((a, b) => a.hash.localeCompare(b.hash, 'en')).map(next));
        break;
      }
    case 'Boolean':
      {
        tsType = t.tsBooleanKeyword();
        break;
      }
    case 'Number':
      {
        tsType = t.tsNumberKeyword();
        break;
      }
    case 'Object':
      {
        tsType = t.tsTypeLiteral(node.properties.sort((a, b) => a.key.localeCompare(b.key, 'en')).map(({
          key,
          value
        }) => {
          const valueIsOptional = (0, _utils.isStructureOptional)(value);
          const propertySignature = t.tsPropertySignature(t.stringLiteral(key), t.tsTypeAnnotation(next(valueIsOptional ? (0, _utils.removeOptional)(value) : value)));
          propertySignature.optional = valueIsOptional;
          return propertySignature;
        }));
        break;
      }
    case 'Or':
      {
        tsType = t.tsUnionType(node.children.sort((a, b) => a.hash.localeCompare(b.hash, 'en')).map(next));
        break;
      }
    case 'String':
      {
        tsType = node.value ? t.tsLiteralType(t.stringLiteral(node.value)) : t.tsStringKeyword();
        break;
      }
    case 'Unknown':
      {
        tsType = t.tsUnknownKeyword();
        break;
      }
    case 'Lazy':
      {
        tsType = next(node.get());
        break;
      }
    case 'Reference':
      {
        tsType = t.tsTypeReference(t.tsQualifiedName(t.identifier('Sanity'), t.identifier('Reference')), t.tsTypeParameterInstantiation([next(node.to)]));
        break;
      }
    case 'Array':
      {
        tsType = t.tsArrayType(next((0, _utils.isStructureOptional)(node.of) ? (0, _utils.removeOptional)(node.of) : node.of));
        break;
      }
    case 'Tuple':
      {
        tsType = t.tsTupleType(node.elements.map(next));
        break;
      }
    default:
      {
        // TODO: better comment
        // @ts-expect-error
        throw new Error(node.type);
      }
  }
  if ('canBeNull' in node || 'canBeOptional' in node) {
    const types = [tsType];
    if (node.canBeNull) types.push(t.tsNullKeyword());
    if (node.canBeOptional) types.push(t.tsUndefinedKeyword());
    tsType = t.tsUnionType(types);
  }
  return tsType;
}