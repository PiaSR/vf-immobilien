import { existsSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { findBlueprintFile, writeBlueprintToDisk } from '../../actions/blueprints/blueprint.js';
import { writeConfigFile } from '../../actions/blueprints/config.js';
import { createEmptyStack, getStack } from '../../actions/blueprints/stacks.js';
import { writeGitignoreFile } from '../../actions/git.js';
import { writeOrUpdateNodeDependency } from '../../actions/node.js';
import { verifyExampleExists, writeExample } from '../../actions/sanity/examples.js';
import { getProject } from '../../actions/sanity/projects.js';
import { BLUEPRINT_CONFIG_FILE, BLUEPRINT_DIR } from '../../config.js';
import { check, warn } from '../../utils/display/presenters.js';
import { promptForProject } from '../../utils/display/prompt.js';
const SCOPE_PROJECT = 'project';
const SCOPE_ORGANIZATION = 'organization';
export async function blueprintInitCore(options) {
    const { bin = 'sanity', log, token, args, flags } = options;
    try {
        const { dir: flagDir, example: flagExample, 'blueprint-type': flagBlueprintType, 'project-id': flagProjectId, 'organization-id': flagOrganizationId, 'stack-id': flagStackId, 'stack-name': flagStackName, } = flags;
        const { dir: argDir } = args;
        const userProvidedDirName = argDir || flagDir;
        const blueprintDir = userProvidedDirName || '.';
        const existingBlueprint = findBlueprintFile(blueprintDir);
        if (existingBlueprint) {
            return { success: false, error: 'Existing Blueprint found.' };
        }
        const validationError = validateFlags({
            stackId: flagStackId,
            stackName: flagStackName,
            organizationId: flagOrganizationId,
            projectId: flagProjectId,
        });
        if (validationError)
            return validationError;
        if (flagExample) {
            return handleExampleInitialization({
                exampleName: flagExample,
                projectId: flagProjectId,
                blueprintDir,
                userProvidedDirName,
                token,
                log,
            });
        }
        const { scopeType, scopeId, stackId } = await resolveScopeAndStack({
            projectId: flagProjectId,
            organizationId: flagOrganizationId,
            stackId: flagStackId,
            stackName: flagStackName,
            token,
            log,
        });
        const blueprintExtension = await determineBlueprintExtension({
            requestedType: flagBlueprintType,
            blueprintDir,
        });
        return createBlueprintFiles({
            blueprintDir,
            userProvidedDirName,
            blueprintExtension,
            scopeType,
            scopeId,
            stackId,
            bin,
            log,
        });
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log(`Error: ${errorMessage}`);
        return { success: false, error: errorMessage };
    }
}
export function validateFlags(flags) {
    const { stackId, stackName, organizationId, projectId } = flags;
    if (stackId && stackName) {
        return { success: false, error: 'Cannot specify both --stack-id and --stack-name' };
    }
    if (organizationId && projectId) {
        return { success: false, error: 'Cannot specify both --organization-id and --project-id' };
    }
    return null;
}
async function handleExampleInitialization(options) {
    const { exampleName, blueprintDir, userProvidedDirName, projectId, token, log } = options;
    log(warn(`Example feature is experimental. Setting up "${exampleName}"...`));
    const exampleExists = await verifyExampleExists({ type: 'blueprint', name: exampleName });
    if (!exampleExists) {
        return { success: false, error: `Blueprint example "${exampleName}" does not exist.` };
    }
    const resolvedProjectId = projectId || (await promptForProject({ token })).projectId;
    const stack = await createEmptyStack({
        token,
        scopeType: SCOPE_PROJECT,
        scopeId: resolvedProjectId,
        name: `example-${exampleName}`,
        projectBased: false,
    });
    const exampleDir = userProvidedDirName || join(blueprintDir, exampleName);
    if (existsSync(exampleDir)) {
        return { success: false, error: `Example directory "${exampleDir}" already exists.` };
    }
    const addedExample = await writeExample({
        exampleType: 'blueprint',
        exampleName,
        dir: exampleDir,
    });
    if (!addedExample) {
        return { success: false, error: `Unable to download example "${exampleName}"` };
    }
    const { files, dir: newDir, instructions } = addedExample;
    for (const filePath of Object.keys(files)) {
        log(check(`${chalk.bold('Created:')}    ${newDir}/${filePath}`));
    }
    const discoveredBlueprint = findBlueprintFile(exampleDir);
    if (!discoveredBlueprint) {
        return { success: false, error: 'Failed to find blueprint file.' };
    }
    const { blueprintFilePath } = discoveredBlueprint;
    writeConfigFile({ blueprintFilePath, projectId: resolvedProjectId, stackId: stack.id });
    log(check(`${chalk.bold('Configured:')} ${exampleDir}/${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`));
    log(`\n  Run "${chalk.bold.magenta(`cd ${exampleDir} && npm i`)}" and check out the README`);
    if (instructions) {
        log('');
        log(instructions);
    }
    return { success: true };
}
export async function resolveScopeAndStack(params) {
    const { projectId, organizationId, stackId, stackName, token, log } = params;
    let scopeType = SCOPE_PROJECT;
    let scopeId;
    if (projectId) {
        scopeType = SCOPE_PROJECT;
        scopeId = projectId;
    }
    else if (organizationId) {
        scopeType = SCOPE_ORGANIZATION;
        scopeId = organizationId;
    }
    let resolvedStackId = stackId;
    if (!resolvedStackId && stackName && scopeType && scopeId) {
        // essentially the only way to create an org-scoped stack
        const stack = await createEmptyStack({
            token,
            scopeType,
            scopeId,
            name: stackName,
            projectBased: false,
        });
        resolvedStackId = stack.id;
    }
    if (!scopeId) {
        const pickedProject = await promptForProject({ token });
        scopeType = SCOPE_PROJECT;
        scopeId = pickedProject.projectId;
    }
    if (!resolvedStackId) {
        await getOrCreateProjectBasedStack({ token, projectId: scopeId, log });
    }
    return {
        scopeType,
        scopeId,
        stackId: resolvedStackId,
    };
}
export async function determineBlueprintExtension(params) {
    const { requestedType, blueprintDir } = params;
    const extension = requestedType || (await promptForBlueprintType());
    if (extension === 'js') {
        const packageJsonPath = join(blueprintDir, 'package.json');
        const packageExists = existsSync(packageJsonPath);
        if (packageExists) {
            try {
                const packageJson = readFileSync(packageJsonPath, 'utf8');
                const packageJsonObject = JSON.parse(packageJson);
                if (packageJsonObject.type !== 'module') {
                    return 'mjs';
                }
            }
            catch { }
        }
    }
    return extension;
}
export async function createBlueprintFiles(params) {
    const { blueprintDir, userProvidedDirName, blueprintExtension, scopeType, scopeId, stackId, bin, log, } = params;
    if (!blueprintExtension) {
        return { success: false, error: 'Blueprint type is required.' };
    }
    const blueprintFileName = `sanity.blueprint.${blueprintExtension}`;
    const blueprintFilePath = join(blueprintDir, blueprintFileName);
    writeBlueprintToDisk({ blueprintFilePath });
    if (userProvidedDirName) {
        log(check(`${chalk.bold('New folder created:')}  ${userProvidedDirName}/`));
    }
    const displayPath = userProvidedDirName || '.';
    log(check(`${chalk.bold('Created Blueprint:')}   ${displayPath}/${blueprintFileName}`));
    writeConfigFile({
        blueprintFilePath,
        stackId,
        ...(scopeType === SCOPE_ORGANIZATION ? { organizationId: scopeId } : { projectId: scopeId }),
    });
    log(check(`${chalk.bold('Added configuration:')} ${displayPath}/${BLUEPRINT_DIR}/${BLUEPRINT_CONFIG_FILE}`));
    writeGitignoreFile(blueprintFilePath);
    log(check(`${chalk.bold('Added .gitignore:')}    ${displayPath}/.gitignore`));
    if (blueprintExtension !== 'json') {
        const blueprintsPackage = '@sanity/blueprints';
        try {
            await writeOrUpdateNodeDependency(blueprintFilePath, blueprintsPackage);
            log(check(`${chalk.bold('Added dependency:')}    ${blueprintsPackage}`));
        }
        catch {
            log(warn(`Unable to add ${blueprintsPackage} to your project.`));
        }
    }
    const nextStepParts = [];
    if (userProvidedDirName)
        nextStepParts.push(`cd ${userProvidedDirName}`);
    if (blueprintExtension !== 'json')
        nextStepParts.push('npm install');
    nextStepParts.push(`${bin} blueprints --help`);
    log(`\n  Run "${chalk.bold.magenta(nextStepParts.join(' && '))}" to get started`);
    return { success: true };
}
async function promptForBlueprintType() {
    const { pickedBlueprintsType } = await inquirer.prompt([
        {
            type: 'list',
            name: 'pickedBlueprintsType',
            message: 'Choose a Blueprint file type:',
            choices: [
                { name: 'TypeScript', value: 'ts' },
                { name: 'JavaScript', value: 'js' },
                { name: 'JSON', value: 'json' },
            ],
            default: 'ts',
        },
    ]);
    return pickedBlueprintsType;
}
// LAUNCH LIMIT: 1 Stack per Project - create exclusive stack for project
async function getOrCreateProjectBasedStack(params) {
    const { projectId, token, log } = params;
    const { ok: projectOk, project } = await getProject({
        token,
        scopeType: SCOPE_PROJECT,
        scopeId: projectId,
    });
    if (!projectOk) {
        throw new Error('Failed to find Project while creating Stack');
    }
    // check if project has a stack
    const { stack: existingStack, ok: stackOk } = await getStack({
        auth: { token, scopeType: SCOPE_PROJECT, scopeId: projectId },
        stackId: `ST-${projectId}`,
    });
    // if existing stack, return stack
    if (stackOk && existingStack) {
        log(warn(`"${project.displayName}" has an existing deployment.`));
        log(warn(`Deploying an empty Blueprint ${chalk.bold.red('will override the existing deployment!')}`));
        log('');
        return existingStack;
    }
    // if not, create a stack
    const stack = await createEmptyStack({
        token,
        scopeType: SCOPE_PROJECT,
        scopeId: projectId,
        name: project.displayName,
    });
    return stack;
}
